#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Viua Virtual Machine 0.5.0
\end_layout

\begin_layout Author
Marek Marecki
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
mbox{}
\end_layout

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
mbox{}
\end_layout

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Overview
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
This section features a brief overview of the Viua VM; its history, development
 goals, influences and various other bits and pieces of information more
 or less related to the development of the idea and resulting code of the
 virtual machine.
 It is contains more prose and casual writing than technicalities.
 More technical discussion begins in Part 
\begin_inset CommandInset ref
LatexCommand vref
reference "part:Virtual-Machine"

\end_inset

.
 People who want to dive straight into code can start at Part 
\begin_inset CommandInset ref
LatexCommand vref
reference "part:Programming"

\end_inset

 to get the big picture and then go to 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec:Instruction-set"

\end_inset

 to become familiar with the instruction set.
\end_layout

\begin_layout Subsection
License
\end_layout

\begin_layout Standard
Machine's code is released under GNU GPL version 3 license.
\end_layout

\begin_layout Subsection
Compilation and dependencies
\end_layout

\begin_layout Standard
To compile Viua VM one needs a C++11 capable compiler.
 Development is done on Linux machine with GCC 5.1.0.
 From version 0.4.6 machine should also be compilable by clang++ 3.6.1 and above.
 C++11 standard library is the only dependency of the VM.
 To compile the code, following command should be used:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

make -j <number of cores>
\end_layout

\begin_layout Plain Layout

make test
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First command is used to compile assembler, CPU, debugger and disassemler.
 Second command is optional and can be used to verify if VM works correctly.
\end_layout

\begin_layout Standard
Shortcut compilation scripts exist in 
\family typewriter
./scripts
\family default
 directory; 
\family typewriter
./scripts/compile
\family default
 will compile changed pieces with maximal number of threads the machine
 it is run on supports, and 
\family typewriter
./scripts/recompile
\family default
 will recompile whole project.
\end_layout

\begin_layout Subsection
History
\end_layout

\begin_layout Standard
Viua VM is a project that has been started during the Christmas break of
 2014, when I was still a student of Gdansk University of Technology.
 It was meant to be my research project, and to help me understand how languages
 can be implemented and what really happends when I 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 the programs I wrote.
\end_layout

\begin_layout Standard
As to why it has been started at all - I had taken interest in computer
 language design and implementation; lexers, parsers, virtual machines -
 the whole stack.
 The natural way for me was to take a book about the topic, start reading
 it, halfway through begin to implement things described and by the end
 of the book have a working prototype of a software.
 The book that gave me the confidence required to tackle the task of implementin
g a VM was 
\begin_inset Quotes eld
\end_inset

Language Implementation Patterns
\begin_inset Quotes erd
\end_inset

 by Terence Parr.
\end_layout

\begin_layout Standard
Apart from the above, I thought it would be just 
\begin_inset Quotes eld
\end_inset

cool
\begin_inset Quotes erd
\end_inset

 to have my own programming language.
\end_layout

\begin_layout Standard
As of February 2015, Viua VM could be programmed in simple assembly-lookalike
 language and cannot do much compared to mainstream languages.
 Add, subtract, multiply and divide two integers or floats, print a string
 to the screen, call a function (recursively or not).
 It supports separate compilation to some extent (by supporting static linking).
\end_layout

\begin_layout Standard
In April 2015, API for external modules written in C++ has been defined
 which allowed the machine to communicate with the outside world.
\end_layout

\begin_layout Standard
In May 2015, Viua gained the ability to throw and catch objects (among them
 exceptions).
 This confirmed that errors will be handled in the VM via exception catching
 mechanism.
\end_layout

\begin_layout Standard
In June 2015 machine implemented first-class functions and closures which
 enabled it to support some form of functional programming.
\end_layout

\begin_layout Standard
In July 2015 dynamic linking has been implemented, release 0.5.0 has been
 announced and machine entered alpha stage of development.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Comparison with state of the art
\end_layout

\begin_layout Standard
This section discusses the differences between Viua and other popular virtual
 machines and bytecode-driven interpreters that can be considered 
\begin_inset Quotes eld
\end_inset

the current state of the art
\begin_inset Quotes erd
\end_inset

.
 Here, 
\begin_inset Quotes eld
\end_inset

state of the art
\begin_inset Quotes erd
\end_inset

 means what is currently in use, not what is currently the bleeding edge
 of the technology.
 Viua started as a research project, but aims to be a production-ready VM
 instead of pure academic experiment.
\end_layout

\begin_layout Standard
Each subsection will briefly compare Viua with another VM; Viua's advantages
 and disadvantages over the other solution will be discussed (and how they
 can be addressed), preferred use cases, and possibly other aspects.
\end_layout

\begin_layout Subsection
Java
\end_layout

\begin_layout Subsection
Lua
\end_layout

\begin_layout Subsection
Perl
\end_layout

\begin_layout Subsection
Python 3
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Virtual Machine
\begin_inset CommandInset label
LatexCommand label
name "part:Virtual-Machine"

\end_inset


\end_layout

\begin_layout Section
Instruction set
\begin_inset CommandInset label
LatexCommand label
name "sec:Instruction-set"

\end_inset


\end_layout

\begin_layout Standard
This section contains description of the VM's CPU instruction set.
 Each instruction is explained and its syntax is shown so readers can treat
 this section also as a reference for VM's assembly language.
 Opcodes are divided into several groups described under different sections.
 Integer instructions are described
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Integers"

\end_inset

, floating point instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Floats"

\end_inset

, instructions for conversion between builtin types
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Casts"

\end_inset

, Boolean instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Booleans"

\end_inset

, string (text) instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Strings"

\end_inset

, vector (data type) instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Vectors"

\end_inset

, control flow
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Control-flow"

\end_inset

, function calling
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Function-calls"

\end_inset

, closures and functional instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Closures-and-functional"

\end_inset

, operations on registers
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Operations-on-registers"

\end_inset

, exception handling
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Exceptions"

\end_inset

, interfacing with C++ code
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Interfacing-with-C++"

\end_inset

 and other instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Other-instructions"

\end_inset

.
\end_layout

\begin_layout Subsection
Integers
\begin_inset CommandInset label
LatexCommand label
name "sub:Integers"

\end_inset


\end_layout

\begin_layout Standard
These instructions are used to perform common operations on integers (like
 addition, multiplication, or comparison).
\end_layout

\begin_layout Subsubsection
izero
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
izero <register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store integer 0 in given register.
\end_layout

\begin_layout Subsubsection
istore
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
istore <register> <integer operand>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store integer in given register.
\end_layout

\begin_layout Subsubsection
iadd
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
iadd <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Add integer found in second operand to integer found in the first one, and
 store integer result in destination register.
\end_layout

\begin_layout Subsubsection
isub
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
isub <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Subtract integer found in second operand from integer found in the first
 one, and store integer result in destination register.
\end_layout

\begin_layout Subsubsection
imul
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
imul <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Multiply integer found in first operand by integer found in the second one,
 and store integer result in destination register.
\end_layout

\begin_layout Subsubsection
idiv
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
idiv <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Divide integer found in first operand by integer found in the second one,
 and store integer result in destination register.
\end_layout

\begin_layout Subsubsection
iinc
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
iinc <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Increment integer found in target register.
\end_layout

\begin_layout Subsubsection
idec
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
idec <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Decrement integer found in target register.
\end_layout

\begin_layout Subsubsection
ilt
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
ilt <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if integer found in first operand is lesser than integer found in
 the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
ilte
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
ilte <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if integer found in first operand is lesser than or equal to integer
 found in the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
igt
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
igt <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if integer found in first operand is greater than integer found in
 the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
igte
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
igte <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if integer found in first operand is greater than or equal to integer
 found in the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
ieq
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
ieq <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if integer found in first operand is equal to integer found in the
 second one, and store boolean result in destination register.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Floats
\begin_inset CommandInset label
LatexCommand label
name "sub:Floats"

\end_inset


\end_layout

\begin_layout Standard
These instructions are similat to their integer counterparts.
 Float subset lacks increment and decrement instructions, though.
\end_layout

\begin_layout Subsubsection
fstore
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fstore <target register> <float operand>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store a floating point number object in given target register.
\end_layout

\begin_layout Subsubsection
fadd
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fadd <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Add float found in second operand to float found in the first one, and store
 float result in destination register.
\end_layout

\begin_layout Subsubsection
fsub
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fsub <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Subtract float found in second operand from float found in the first one,
 and store float result in destination register.
\end_layout

\begin_layout Subsubsection
fmul
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fmul <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Multiply float found in first operand by float found in the second one,
 and store float result in destination register.
\end_layout

\begin_layout Subsubsection
fdiv
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fdiv <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Divide float found in first operand by float found in the second one, and
 store float result in destination register.
\end_layout

\begin_layout Subsubsection
flt
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
flt <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if float found in first operand is lesser than float found in the
 second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
flte
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
flte <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if float found in first operand is lesser than or equal to float found
 in the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
fgt
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fgt <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if float found in first operand is greater than float found in the
 second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
fgte
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fgte <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if float found in first operand is greater than or equal to float
 found in the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
feq
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
feq <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if float found in first operand is equal to float found in the second
 one, and store boolean result in destination register.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Casts
\begin_inset CommandInset label
LatexCommand label
name "sub:Casts"

\end_inset


\end_layout

\begin_layout Standard
These instructions are used to provide type conversion inside VM.
\end_layout

\begin_layout Subsubsection
itof
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
itof <destination register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Convert integer found in second operand to float, and store result in destinatio
n register.
\end_layout

\begin_layout Subsubsection
ftoi
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
ftoi <destination register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Convert float found in second operand to integer, and store result in destinatio
n register.
\end_layout

\begin_layout Subsubsection
stoi
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
stoi <destination register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Convert string found in second operand to integer, and store result in destinati
on register.
\end_layout

\begin_layout Subsubsection
stof
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
stof <destination register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Convert string found in second operand to float, and store result in destination
 register.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Booleans
\begin_inset CommandInset label
LatexCommand label
name "sub:Booleans"

\end_inset


\end_layout

\begin_layout Standard
Common boolean operations.
\end_layout

\begin_layout Subsubsection
not
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
not <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Invert boolean value of object found in target register.
 Object is converted to Boolean type if needed.
 If a unchanged form of the object is required to remain available, 
\family typewriter
not
\family default
 should be used on a copy of the object.
\end_layout

\begin_layout Subsubsection
and
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
and <target register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store result of logical conjunction of Boolean values of operand objects
 in target register.
\end_layout

\begin_layout Subsubsection
or
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
or <target register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store result of logical disjunction of Boolean values of operand objects
 in target register.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Strings
\begin_inset CommandInset label
LatexCommand label
name "sub:Strings"

\end_inset


\end_layout

\begin_layout Standard
Instructions implementing string support in Viua VM.
\end_layout

\begin_layout Subsubsection
strstore
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
strstore <target register> <string>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store string object in target register.
\end_layout

\begin_layout Subparagraph
Implementation detail
\end_layout

\begin_layout Standard
Strings are stored as null-terminated character sequences in bytecode.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Vectors
\begin_inset CommandInset label
LatexCommand label
name "sub:Vectors"

\end_inset


\end_layout

\begin_layout Standard
Instructions used to perform operations on basic Viua sequences - vectors.
\end_layout

\begin_layout Subsubsection
vec
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vec <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store empty vector in target register.
\end_layout

\begin_layout Subsubsection
vinsert
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vinsert <target register> <object operand register> <position operand>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Insert a copy of object from object operand register into vector, at specified
 position, found in target register.
 Default position is 0.
 At-register reference can be used to load position value from a register.
\end_layout

\begin_layout Subsubsection
vpush
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vpush <target register> <object operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Push a copy of object from object operand register to vector found in target
 register.
\end_layout

\begin_layout Subsubsection
vpop
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vpop <target register> <vector operand register> <position operand>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Pop an object at specified position from vector register and store it in
 target register.
 Default position is -1.
 At-register reference can be used to load position value from a register.
\end_layout

\begin_layout Subsubsection
vat
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vat <target register> <vector operand register> <position operand>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Create a reference in target register, to an object at specified position
 inside vector register.
 Default position is -1.
 At-register reference can be used to load position value from a register.
\end_layout

\begin_layout Subsubsection
vlen
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vlen <target register> <vector operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store length of given vector target register inside target register.
 Result is an integer.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Control flow
\begin_inset CommandInset label
LatexCommand label
name "sub:Control-flow"

\end_inset


\end_layout

\begin_layout Standard
Basic control flow manipulation capabilities.
\end_layout

\begin_layout Subsubsection
jump
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
jump <index>
\end_layout

\begin_layout Paragraph
Assembler syntax
\end_layout

\begin_layout Subparagraph
Jump relative to current function/block entry point
\end_layout

\begin_layout Standard

\family typewriter
jump <index>
\end_layout

\begin_layout Subparagraph
Jump relative to current instruction index
\end_layout

\begin_layout Standard

\family typewriter
jump +<index>
\end_layout

\begin_layout Standard

\family typewriter
jump -<index>
\end_layout

\begin_layout Subparagraph
Jump relative to beginning of executable bytecode (absolute jump)
\end_layout

\begin_layout Standard

\family typewriter
jump .<index>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Unconditional jump to a specified index (byte) inside currently loaded program.
 In ordinary executables jumps can be relative or absolute (as described
 above).
 In library bytecode absolute jumps are prohibited as libraries must be
 relocatable.
\end_layout

\begin_layout Subsubsection
branch
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
branch <condition operand register> <jump if true> <jump if false>
\end_layout

\begin_layout Paragraph
Assembler syntax
\end_layout

\begin_layout Subparagraph
Automatic jump to next instruction if condition is false
\end_layout

\begin_layout Standard

\family typewriter
branch <condition operand register> <jump if true>
\end_layout

\begin_layout Subparagraph
Branch with jumps relative to current instruction index
\end_layout

\begin_layout Standard

\family typewriter
branch <condition> +/-<jump if true> +/-<jump if false>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Conditional jump to a specified index (byte) inside currently loaded program.
 Condition operand may be an object of any type, machine will cast its value
 to Boolean if necessary.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Function and method calls
\begin_inset CommandInset label
LatexCommand label
name "sub:Function-calls"

\end_inset


\end_layout

\begin_layout Standard
This subsection discusses instruction used for calling functions and methods.
 Ordinary function calls can also be used for static dispatch of methods
 to increase runtime performance when correct function to call can be resolved
 at compile time.
\end_layout

\begin_layout Standard
Calling a function means creating a frame for the call and issuing a 
\begin_inset Quotes eld
\end_inset


\family typewriter
call
\family default

\begin_inset Quotes erd
\end_inset

 instruction to existing function.
 No other runtime constraints are placed on function calls.
 One compile time constraint is that 
\begin_inset Quotes eld
\end_inset


\family typewriter
end
\family default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\family typewriter
halt
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
leave
\family default

\begin_inset Quotes erd
\end_inset

 are not allowed to be placed between 
\begin_inset Quotes eld
\end_inset


\family typewriter
frame
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
call
\family default

\begin_inset Quotes erd
\end_inset

 instructions to avoid possibility of creating leftover frames that would
 break the program later during execution.
\end_layout

\begin_layout Standard
There is no unnecessary runtime overhead (apart from instruction decoding)
 for call instructions, the control is immediately transferred to specified
 point in bytecode.
\end_layout

\begin_layout Standard
Calling a method on (or sending a message to) an object means creating a
 frame and issuing a 
\begin_inset Quotes eld
\end_inset


\family typewriter
msg
\family default

\begin_inset Quotes erd
\end_inset

 instruction with name of the message to be dispatched.
 One runtime constraint is that the frame for 
\begin_inset Quotes eld
\end_inset

msg
\begin_inset Quotes erd
\end_inset

 instruction must be passed at least one parameter - the 
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

 object (however, as of Viua 0.5.0.325, commit 
\family typewriter
97ceba0
\family default
, passing it by reference is not enforced) the message should operate on.
 Compile time constraints are the same as for function calls.
\end_layout

\begin_layout Standard
There is runtime overhead involved in dispatching messages to objects related
 to method handler resolution - methods are mapped to functions and this
 indirection must be resolved before the message is dispatched.
 Also, several checks must be performed to ensure safety, i.e.
 the machine has to determine wheter the object accepts the message or not,
 and is the handler function defined.
 Only after passing this verification, is the message dispatched.
\end_layout

\begin_layout Standard
Due to the fact that 
\begin_inset Quotes eld
\end_inset


\family typewriter
msg
\family default

\begin_inset Quotes erd
\end_inset

 involves overhead incurred by runtime checks needed by dynamic dispatch,
 using the 
\begin_inset Quotes eld
\end_inset

call
\begin_inset Quotes erd
\end_inset

 instruction resulting in static dispatch of methods is preffered when possible.
 It should be noted that static dispatch is not available for foreign methods
 of foreign prototypes because of limitations of the technique used for
 C++ class mapping.
 Methods handled with ordinary functions - both foreign and native - can
 be dispatched statically on foreign types, though.
\end_layout

\begin_layout Subsubsection
frame
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
frame <parameters number operand> <local registers number operand>
\end_layout

\begin_layout Paragraph
Assembler syntax
\end_layout

\begin_layout Subparagraph
Frame with default number of local registers
\end_layout

\begin_layout Standard

\family typewriter
frame <parameters number operand>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Create a frame for next function call with specified number of parameter
 slots and local registers.
 Instruction will fail if an unused frame is already present.
\end_layout

\begin_layout Subsubsection
param
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
param <param index> <object operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Put a copy of an object from operand register to parameter slot with given
 index.
 Instruction will fail if no unused frame is present, or if parameter index
 is greater than available number of slots.
\end_layout

\begin_layout Subsubsection
paref
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
paref <param index> <object operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Put a reference to an object from operand register to parameter slot with
 given index.
 Instruction will fail if no unused frame is present, or if parameter index
 is greater than available number of slots.
 This instruction is used for pass-by-reference implementation.
\end_layout

\begin_layout Subsubsection
call
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
call <target register> <function name>
\end_layout

\begin_layout Paragraph
Assembler syntax
\end_layout

\begin_layout Subparagraph
Call that discards returned value
\end_layout

\begin_layout Standard

\family typewriter
call <function name>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Call specified function (native or foreign) and put its return value in
 target register.
 Return value is discarded if return register is set to 0.
 Instruction will fail if no unused frame can be found.
 Instruction will fail if function does not return a value but caller requests
 one (set target register to non-zero value).
 Instruction can fail if a function cannot be found.
\end_layout

\begin_layout Subsubsection
msg
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
msg <target register> <method name>
\end_layout

\begin_layout Paragraph
Assembler syntax
\end_layout

\begin_layout Standard
Assembly language syntax is the same for 
\begin_inset Quotes eld
\end_inset


\family typewriter
call
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
msg
\family default

\begin_inset Quotes erd
\end_inset

 instructions.
 However, 
\begin_inset Quotes eld
\end_inset


\family typewriter
msg
\family default

\begin_inset Quotes erd
\end_inset

 instruction required to have an object passed as first parameter.
\end_layout

\begin_layout Subparagraph
Sample method call
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
new 1 Object
\end_layout

\begin_layout Standard

\family typewriter
frame ^[(paref 0 1)]
\end_layout

\begin_layout Standard

\family typewriter
msg 0 method
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Calls a method on an object, resulting in dynamic dispatch of handler function.
 First parameter passed is the object that will be operated on.
 Instruction will fail when no unused frame can be found.
 Instruction will fail if method does not return a value but caller requested
 one.
 Instruction will fail if object's type does not accept specified method.
 Instruction will fail if handler function is undefined.
\end_layout

\begin_layout Subsubsection
arg
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
arg <target register> <param index>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Put a copy of object found in specified parameter index into target register,
 or create a reference to an object found in specified parameter index in
 target register (if pass-by-reference has been used for this parameter).
\end_layout

\begin_layout Subsubsection
argc
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
argc <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store an integer indicating how many parameters the function has been called
 with.
\end_layout

\begin_layout Subsubsection
end
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
end
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Finish execution of current frame and return control to caller function.
 If the function should return a value, this value must be put into register
 0 (return register) before 
\family typewriter
end
\family default
 instruction is reached.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Closures and functional
\begin_inset CommandInset label
LatexCommand label
name "sub:Closures-and-functional"

\end_inset


\end_layout

\begin_layout Standard
Closure instructions.
 Closures are first-class objects inside Viua VM.
 Their semantics differ slightly from those of ordinary functions.
\end_layout

\begin_layout Subsubsection
clbind
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
clbind <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Mark given register with 
\begin_inset Quotes eld
\end_inset

to be bound
\begin_inset Quotes erd
\end_inset

 flag.
 This flag is needed for closure instruction to know which objects should
 be bound by it.
 This flag will be reset by nex closure instruction.
\end_layout

\begin_layout Subsubsection
closure
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
closure <target register> <function name>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Create a closure from given function and store it in target register.
\end_layout

\begin_layout Subsubsection
function
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
function <target register> <function name>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Create a function object from given function and store it in target register.
\end_layout

\begin_layout Subsubsection
fcall
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fcall <target register> <callable object register index>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Call object found in specified register.
 This instruction will fail if the object is neither a function object nor
 a closure.
 Apart from this fact, this and 
\family typewriter
call
\family default
 instruction's semantics are the same.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Operations on registers
\begin_inset CommandInset label
LatexCommand label
name "sub:Operations-on-registers"

\end_inset


\end_layout

\begin_layout Standard
Instructions used to perform type-agnostic operations on registers.
 These include: copying, moving, swapping etc.
\end_layout

\begin_layout Subsubsection
move
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
move <target register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Move object from source to target register.
 Source register is then set to point to 0.
 All flags are cleared for source register.
\end_layout

\begin_layout Subsubsection
copy
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
copy <target register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Copy object from source to target register.
\end_layout

\begin_layout Subsubsection
ref
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
ref <target register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Create a reference to object from source register in target register.
 This instruction causes target register to become flagged as a 
\begin_inset Quotes eld
\end_inset

reference holding register
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
swap
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
swap <first operand register> <second operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Swap objects in first and second operand registers.
 Flags are also swapped.
\end_layout

\begin_layout Subsubsection
free
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
free <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Delete an object found in target register.
 All flags are cleared for target register.
 Instruction will fail if register is empty.
\end_layout

\begin_layout Subparagraph
Implementation detail
\end_layout

\begin_layout Standard
Instruction can cause crashes if deleted object is referenced elsewhere.
\end_layout

\begin_layout Subsubsection
empty
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
empty <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Make target register point to 0.
 All flags are cleared for target register.
\end_layout

\begin_layout Subparagraph
Implementation detail
\end_layout

\begin_layout Standard
Instruction can lead to memory leaks if the register holds the only pointer
 to an object, or if only remaining pointers to an object are marked as
 references - as machine does not automaticallty delete references.
\end_layout

\begin_layout Subsubsection
isnull
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
isnull <target register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if source register is empty.
 Stores boolean result in target register.
\end_layout

\begin_layout Subsubsection
ress
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
ress <register set id>
\end_layout

\begin_layout Paragraph
Assembler syntax
\end_layout

\begin_layout Subparagraph
Switching to global register set
\end_layout

\begin_layout Standard

\family typewriter
ress global
\end_layout

\begin_layout Subparagraph
Switching to local register set
\end_layout

\begin_layout Standard

\family typewriter
ress local
\end_layout

\begin_layout Subparagraph
Switching to static register set
\end_layout

\begin_layout Standard

\family typewriter
ress static
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Switch current register set used.
\end_layout

\begin_layout Subparagraph
Implementation detail
\end_layout

\begin_layout Standard
Static register set is allocated for a function first time it requests one.
 Currently there is no way to specify which functions are and which are
 not allowed to request a switch to static register set.
\end_layout

\begin_layout Subsubsection
tmpri
\end_layout

\begin_layout Standard
This instruction and its 
\family typewriter
tmpro
\family default
 counterpart can be used to transfer values between different register sets.
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
tmpri <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Put a copy of object from source register in temporary register.
\end_layout

\begin_layout Subparagraph
Implementation detail
\end_layout

\begin_layout Standard
Instruction must be used with caution - it will cause memory leak if temporary
 register is overwritten.
\end_layout

\begin_layout Subsubsection
tmpro
\end_layout

\begin_layout Standard
This instruction and its 
\family typewriter
tmpro
\family default
 counterpart can be used to transfer values between different register sets.
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
tmpro <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Move object from temporary register to target register.
\end_layout

\begin_layout Subparagraph
Implementation detail
\end_layout

\begin_layout Standard
Instruction must be used with caution - it may cause crashes and memory
 leaks if target register is overwritten.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Exceptions
\begin_inset CommandInset label
LatexCommand label
name "sub:Exceptions"

\end_inset


\end_layout

\begin_layout Subsubsection
tryframe
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
tryframe
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Create a frame for trying a block.
\end_layout

\begin_layout Subsubsection
catch
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
catch <type> <handler block>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Registers handler block for a type.
 Instruction fails if no 
\family typewriter
tryframe
\family default
 is available.
\end_layout

\begin_layout Subsubsection
try
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
try <block>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Tries to execute a block.
 Instruction fails if no 
\family typewriter
tryframe
\family default
 is available.
\end_layout

\begin_layout Subsubsection
throw
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
throw <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Throw object found in given register.
\end_layout

\begin_layout Subsubsection
pull
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
pull <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Put caught object in target register.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Dynamic linking
\end_layout

\begin_layout Subsubsection
link
\begin_inset CommandInset label
LatexCommand label
name "sub:link"

\end_inset


\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
link <module>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Dynamically link a module.
 Instruction fails if a module cannot be found, or cannot be loaded (e.g.
 when it has been incorrectly compiled).
 Brief description of dynamic linking can be found 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Dynamic-linking"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Interfacing with C++ modules
\begin_inset CommandInset label
LatexCommand label
name "sub:Interfacing-with-C++"

\end_inset


\end_layout

\begin_layout Subsubsection
import
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
import <module>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Import an external C++ module.
 Instruction fails if a module cannot be found, or does not provide valid
 interface.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Other instructions
\begin_inset CommandInset label
LatexCommand label
name "sub:Other-instructions"

\end_inset


\end_layout

\begin_layout Standard
Various instructions that do not fit into any other category.
\end_layout

\begin_layout Subsubsection
echo
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
echo <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Print stringified contents of target register to standard output.
 Does not put trailing newline.
\end_layout

\begin_layout Subsubsection
print
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
print <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Print stringified contents of target register to standard output.
 Prints trailing newline.
\end_layout

\begin_layout Subsubsection
nop
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
nop
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Do nothing.
\end_layout

\begin_layout Subsubsection
halt
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
halt
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Unconditionally halt execution of the program and exit the machine.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Instruction operands
\end_layout

\begin_layout Standard
Instructions operate on registers and usually operands are just register
 indexes, this is the simplest case.
\end_layout

\begin_layout Subsection
Values
\end_layout

\begin_layout Standard
Registers that contain a value are overwritten when another value is put
 in them.
\end_layout

\begin_layout Subsection
References
\end_layout

\begin_layout Standard
Registers that contain a reference are not overwritten; instead, they adjust
 the value of the object they reference.
 The change appears in every register that holds a reference to changed
 object.
\end_layout

\begin_layout Subsection
At-register operator
\end_layout

\begin_layout Standard
If an operand is an integer it can be preceded by @ character in source
 code to create an at-register operand.
 This @ (called 
\begin_inset Quotes eld
\end_inset

at-register operator
\begin_inset Quotes erd
\end_inset

) will cause the flag before integer operand to be set to true which is
 interpreted by machine's CPU as 
\begin_inset Quotes eld
\end_inset

do not treat this literally, but rather as a register index to take actual
 value from
\begin_inset Quotes erd
\end_inset

.
 When the operand is already a register index and is preceded by at-register
 operator, machine will use value found in this register as the index used
 for final operation.
\end_layout

\begin_layout Subsubsection
Example - instruction taking register index as an operand
\end_layout

\begin_layout Standard
If an instruction takes register index (an integer) as its operand and this
 integer is preced by at-register operator, machine will use value found
 in register with index equal to given integer as the final index: 
\begin_inset Quotes eld
\end_inset

izero 1
\begin_inset Quotes erd
\end_inset

 will store 0 in first regitser, but 
\begin_inset Quotes eld
\end_inset

izero @1
\begin_inset Quotes erd
\end_inset

 will store 0 in register with index equal to the integer stored in first
 register.
\end_layout

\begin_layout Subsubsection
Example - instruction taking integer as an operand
\end_layout

\begin_layout Standard
If an instruction takes plain integer as its operand and this integer is
 preceded by at-register operator, machine will use value found in register
 with index equal to given integer as this operand: 
\begin_inset Quotes eld
\end_inset

istore 1 42
\begin_inset Quotes erd
\end_inset

 will store 42 in first register, but 
\begin_inset Quotes eld
\end_inset

istore 1 @42
\begin_inset Quotes erd
\end_inset

 will store in first register whatever integer was stored in register 42.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Program excution
\end_layout

\begin_layout Subsection
Entry point
\end_layout

\begin_layout Standard
This subsection explains how does the execution start.
\end_layout

\begin_layout Subsubsection
Hardcoded entry function
\end_layout

\begin_layout Standard
Describe entry function hardcoded inside the machine, which is also the
 first function to be executed when a program is run on Viua.
\end_layout

\begin_layout Subsubsection
User supplied main function
\end_layout

\begin_layout Standard
Describe the main function a user should supply.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Calling conventions
\end_layout

\begin_layout Standard
This subsection explains calling conventions in Viua.
\end_layout

\begin_layout Subsubsection
Call frames
\end_layout

\begin_layout Standard
Describe layout of a single call frame.
\end_layout

\begin_layout Subsubsection
Passing parameters
\end_layout

\begin_layout Standard
How does the parameters get passed to functions.
 Explain pass-by-value and pass-by-reference.
\end_layout

\begin_layout Subsubsection
Call address resolution
\end_layout

\begin_layout Standard
How does the machine determine the location to which execution pointer should
 be set when calling a function?
\end_layout

\begin_layout Subsubsection
Returning from calls
\end_layout

\begin_layout Standard
What happens when a function returns?
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Call stack
\end_layout

\begin_layout Standard
This subsection explains call stack in Viua.
\end_layout

\begin_layout Subsubsection
Not a stack
\end_layout

\begin_layout Standard
Call stack in Viua is not really a stack, but a vector.
 Implementation detail.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Exception handling
\end_layout

\begin_layout Standard
This subsection explains in detail how exceptions are handled inside Viua.
\end_layout

\begin_layout Subsubsection
Creating tryframes
\end_layout

\begin_layout Subsubsection
Registering catching blocks
\end_layout

\begin_layout Subsubsection
Trying blocks
\end_layout

\begin_layout Subsubsection
Leaving blocks
\end_layout

\begin_layout Subsubsection
Block stack
\end_layout

\begin_layout Standard
Try-frames are placed on a stack separate from ordinary call-frame stack,
 but are closely tied to their respective frames.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Register sets
\begin_inset CommandInset label
LatexCommand label
name "sec:Register-sets"

\end_inset


\end_layout

\begin_layout Subsection
A register set
\end_layout

\begin_layout Standard
Register set is a collection of registers.
\end_layout

\begin_layout Subsection
A register
\end_layout

\begin_layout Standard
A register is a pointer holding a pointer to an object.
 In Viua, a 
\begin_inset Quotes eld
\end_inset

register
\begin_inset Quotes erd
\end_inset

 is a piece of memory, with some associated flags, inside a register set
 that holds a pointer to an object.
\end_layout

\begin_layout Subsubsection
Register flags
\end_layout

\begin_layout Subsection
Available register sets
\end_layout

\begin_layout Standard
Viua is a register-based virtual machine.
 It comes with several register sets, and each serves different purpose.
\end_layout

\begin_layout Subsubsection
Global
\end_layout

\begin_layout Standard
Global register set can be used to hold global variables.
 It can be accessed from all functions.
 Initial values in this register set's registers are set by 
\family typewriter
__entry
\family default
 function.
\end_layout

\begin_layout Subsubsection
Local
\end_layout

\begin_layout Standard
Local regster sets are uniqe to functions and cannot be accessed from outside
 of them.
 They are created each time a function is called, live inside a call frame
 and are destoyed when the frame is popped from the call stack.
\end_layout

\begin_layout Subsubsection
Static
\end_layout

\begin_layout Standard
Static registers are unique to functions and cannot be accessed from outside
 of them.
 The difference between local registers is that they are created only the
 first time a function is called and are independent of call frames.
\end_layout

\begin_layout Subsubsection
Temporary
\end_layout

\begin_layout Standard
Temporary register set has only one register.
 It is used to move values between different register sets.
 In the future release, the number of registers in the temporary register
 set may be increased to allow performing simple operations inside it.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Type system
\begin_inset CommandInset label
LatexCommand label
name "sec:Type-system"

\end_inset


\end_layout

\begin_layout Standard
This section describes the type system implemented inside Viua virtual machine.
 First, a high level overview of the system is presented to give the reader
 a broad view; then, in each following section, various aspects of the system
 are discussed in more detail - the type hierarchy used by machine and its
 parts exposed to user code, inheritance, object construction and destruction,
 method overloading and dispatch, etc.
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
Type system implemented in Viua is expressed by two ideas: a prototype,
 and an object.
\end_layout

\begin_layout Subsubsection
Prototype
\end_layout

\begin_layout Standard
Prototype is a description of a class (the 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

class
\begin_inset Quotes erd
\end_inset

 are considered synonymous), i.e.
 what methods it exposes, and the list of classes it inherits from.
 Inheritance linearizations (and, thus, method resolution order chains)
 can be from the typesystem map built from prototypes.
\end_layout

\begin_layout Standard
Prototypes can be defined using instructions provided by Viua CPU instruction
 set, or using 
\begin_inset Quotes eld
\end_inset


\family typewriter
.class:
\family default

\begin_inset Quotes erd
\end_inset

 blocks in source code (in which case the compiler must turn the class-block
 definition into instruction-sequence definition).
 Regardless of the method with which they are defined, all prototypes are
 constructed and registered in machine's typesystem at runtime (but it is
 possible for the compiler to check code for type correctness during compilation
 as class information is present in the source code).
 However, prototypes defined using 
\begin_inset Quotes eld
\end_inset


\family typewriter
.class:
\family default

\begin_inset Quotes erd
\end_inset

 blocks are guaranteed to be available before 
\begin_inset Quotes eld
\end_inset


\family typewriter
main
\family default

\begin_inset Quotes erd
\end_inset

 function is entered which may be desirable.
 No guarantee is provided that class-block defined prototypes will be available
 at the time libraries specified by 
\begin_inset Quotes eld
\end_inset

VIUAPRELINK
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

VIUAPREIMPORT
\begin_inset Quotes erd
\end_inset

 are being loaded into the machine.
\end_layout

\begin_layout Standard
Existing prototypes can be modified (and new ones can be defined) at runtime
 using instructions provided by Viua CPU.
 This, along with reloading of the libraries, provides a robust system for
 creating long-running processes that require minium downtime (similar to
 what Erlang provides).
\end_layout

\begin_layout Standard
Prototypes do not own their methods as they are being 
\begin_inset Quotes eld
\end_inset

composed
\begin_inset Quotes erd
\end_inset

 from existing components - a class is created empty, then it may be derived
 from another, already existing, class, and finally have some methods attached.
 The concept of 
\begin_inset Quotes eld
\end_inset

attaching
\begin_inset Quotes erd
\end_inset

 a method is the key one - on the lowest level, method names attached to
 a class are mapped to names of ordinary functions and are resolved when
 the 
\begin_inset Quotes eld
\end_inset


\family typewriter
msg
\family default

\begin_inset Quotes erd
\end_inset

 instruction is called to issue a method call on an object.
 The only thing special about functions that are attached to prototypes
 as methods is the fact that they must take an object of correct type as
 their first parameter.
 This way of composing prototypes, where methods are ordinary functions
 attached with changed name to the prototype, enables the compiler to generate
 faster code by using static dispatch and simply calling the function without
 going through the indirection of resolving a method name.
 This is essentially the same technique that can be used for C++: virtual
 methods are called after resolving vtable-stored member-function pointers,
 and non-virtual methods are called using static dispatch; it provides flexibili
ty where polymorphic behaviour is needed, and zero-overhead (when compared
 to simple function call) performance in critical parts of the program.
\end_layout

\begin_layout Subsubsection
Object
\end_layout

\begin_layout Standard
An object is a structure with assigned type (it is possible to define 
\begin_inset Quotes eld
\end_inset

typeless
\begin_inset Quotes erd
\end_inset

 objects whose type will be just 
\begin_inset Quotes eld
\end_inset

Object
\begin_inset Quotes erd
\end_inset

 but they do not provide much functionality apart from setting and retrieving
 values) and named data fields.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Callables
\begin_inset CommandInset label
LatexCommand label
name "sec:Callables"

\end_inset


\end_layout

\begin_layout Standard
Callble objects in Viua VM.
\end_layout

\begin_layout Subsection
Functions
\begin_inset CommandInset label
LatexCommand label
name "sub:Functions"

\end_inset


\end_layout

\begin_layout Standard
Function objects are currently not implemented.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Closures
\begin_inset CommandInset label
LatexCommand label
name "sub:Closures"

\end_inset


\end_layout

\begin_layout Standard
Viua has direct support for closures and, when programming in machine's
 assembly, precise control over object binding can be achieved.
 Closures are first-class objects inside Viua's type system.
 However, there are a few limitations.
\end_layout

\begin_layout Subsubsection
Creating closures
\end_layout

\begin_layout Standard
A closure can be created from any defined function written in machine's
 assembly.
 Creating closures from external functions (imported from C++ modules) is
 not supported.
\end_layout

\begin_layout Standard
Before a closure is created, machine scans current register set for registers
 marked with BIND flag.
 Any such mared register is then inserted into the local registerset of
 a closure - where it has REFERENCE flag set - and flag in current registerset
 is changed from BIND to BOUND.
 It is allowed to create closures that bind no objects - such empty closures
 can be used as a function objects.
\end_layout

\begin_layout Subsubsection
Object sharing
\end_layout

\begin_layout Standard
If an object is bound to more than one closure, pointer to this object stays
 the same in all binding closures.
 It must be noted that binding objects to multiple closures leads to memory
 leaks.
 Due to the naive way machine tracks objects lifetimes it will not be able
 to determine when it can destroy a bound object because all pointers to
 it are either REFERENCEs or in BOUND registers.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Coroutines
\begin_inset CommandInset label
LatexCommand label
name "sub:Coroutines"

\end_inset


\end_layout

\begin_layout Standard
Coroutines are a planned but currently not implemented feature.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Environment variables
\end_layout

\begin_layout Standard
Viua VM uses several environment variables to adjust its behaviour.
\end_layout

\begin_layout Subsection

\family typewriter
VIUAPATH
\end_layout

\begin_layout Standard
This environment variable is a colon-separated list of paths that should
 be searched for dynamically linked libraries (both native and foreign)
 before any hardcoded path is searched.
\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard

\family typewriter
VIUAPATH=./build:/home/joe/lib/viua
\end_layout

\begin_layout Subsection

\family typewriter
VIUAAFTERPATH
\end_layout

\begin_layout Standard
This environment variable is a colon-separated list of paths that should
 be searched for dynamically linked libraries (both native and foreign)
 after all hardcoded paths have neen searched.
\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard

\family typewriter
VIUAAFTERPATH=./build:/home/joe/lib/viua
\end_layout

\begin_layout Subsection

\family typewriter
VIUAPRELINK
\end_layout

\begin_layout Standard
This environment variable is a colon-separated list of native dynamic libraries
 that should be loaded into memory before 
\family typewriter

\begin_inset Quotes eld
\end_inset

main
\begin_inset Quotes erd
\end_inset


\family default
 function is entered.
\end_layout

\begin_layout Subsection

\family typewriter
VIUAPREIMPORT
\end_layout

\begin_layout Standard
This environment variable is a colon-separated list of foreign dynamic libraries
 that should be loaded into memory before 
\family typewriter

\begin_inset Quotes eld
\end_inset

main
\begin_inset Quotes erd
\end_inset


\family default
 function is entered.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Bytecode
\end_layout

\begin_layout Standard
This section talks about the bytecode used by Viua VM.
\end_layout

\begin_layout Section
Executable
\end_layout

\begin_layout Standard
This subsection discusses bytecode format used for executable files.
 Each subsection discusses a coresponding section of the bytecode format,
 all sections appear in text in the exact same order as they appear in bytecode.
\end_layout

\begin_layout Subsection
Function mapping
\end_layout

\begin_layout Standard
Function mapping begins with 
\family typewriter
uint16_t
\family default
 encoding size of the section.
 Following N bytes contain paired function names (encoded as null-terminated
 strings, thus variable length) and locations of their entry points (encoded
 as 
\family typewriter
uint16_t
\family default
 integers).
\end_layout

\begin_layout Standard
Format can be written as such:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<section size:uint16_t>
\end_layout

\begin_layout Plain Layout

(<name:null-terminated-string><entry_point:uint16_t>)+
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is a 
\family typewriter
+
\family default
 rather than 
\family typewriter
*
\family default
 after name/entry-point pair because there are always at least two functions
 mapped: 
\family typewriter
__entry
\family default
 and 
\family typewriter
main
\family default
.
\end_layout

\begin_layout Subsection
Block mapping
\end_layout

\begin_layout Standard
Block mapping begins with 
\family typewriter
uint16_t
\family default
 encoding size of the section.
 A block is a piece of code that is executed when throw-catch mechanism
 is in use, i.e.
 VM 
\begin_inset Quotes eld
\end_inset

tries
\begin_inset Quotes erd
\end_inset

 to execute a block, and if an exception is thrown, it executes the block
 that should 
\begin_inset Quotes eld
\end_inset

catch
\begin_inset Quotes erd
\end_inset

 it the exception.
\end_layout

\begin_layout Standard
The format is exactly the same as for function mapping.
\end_layout

\begin_layout Subsection
Executable bytecode size
\end_layout

\begin_layout Standard
Last name/entry-point pair from function mapping section is followed size
 of the executable bytecode encoded as 
\family typewriter
uint16_t
\family default
.
\end_layout

\begin_layout Subsection
Executable bytes
\end_layout

\begin_layout Standard
Size is followed by N bytes containing encoded opcodes with program logic.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Linkable
\end_layout

\begin_layout Standard
This section discusses bytecode format used for libraries.
 In Viua VM there is no difference between a static and dynamic libraries.
 In fact, a library can be linked statically or dynamically without any
 changes.
 The only difference is between linkable and executable bytecode formats.
\end_layout

\begin_layout Subsection
Jump table
\end_layout

\begin_layout Standard
Linkable bytecode format begins with encoded jump table.
 This is because jumps must be recalculated before linking and providing
 jump table is faster than manually scanning bytecode for 
\family typewriter
JUMP
\family default
 and 
\family typewriter
BRANCH
\family default
 instructions.
\end_layout

\begin_layout Standard
This section begins with an 
\family typewriter
unsigned
\family default
 encoding total number of entries in the jump table.
 It is followed by N 
\family typewriter
unsigned
\family default
 integers encoding positions of jumps in linked bytecode.
 During linking they must be adjusted by increasing their targets by total
 size of bytecode that precedes them.
 The schema may look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<jumptable size:unsigned>
\end_layout

\begin_layout Plain Layout

<jump position in bytecode:unsigned>*
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Function mapping
\end_layout

\begin_layout Standard
Function mapping has the same structure as in executable bytecode format.
\end_layout

\begin_layout Subsection
Block mapping
\end_layout

\begin_layout Standard
Block mapping has the same structure as in executable bytecode format.
\end_layout

\begin_layout Subsection
Executable bytecode size
\end_layout

\begin_layout Standard
Last name/entry-point pair from function mapping section is followed size
 of the executable bytecode encoded as 
\family typewriter
uint16_t
\family default
.
\end_layout

\begin_layout Subsection
Executable bytes
\end_layout

\begin_layout Standard
Size is followed by N bytes containing encoded opcodes with library logic.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Programming
\begin_inset CommandInset label
LatexCommand label
name "part:Programming"

\end_inset


\end_layout

\begin_layout Standard
This part describes how to write programs and run them on Viua VM.
 The language used in this part is custom assembly language created for
 the VM (it is also a target to which higher-level languages can be compiled).
\end_layout

\begin_layout Section
Structure
\end_layout

\begin_layout Standard
Every Viua VM program is a composed from a set of functions.
 In fact, each assembled file must contain at least one function.
\end_layout

\begin_layout Standard
If any instruction is found outside of a function it is gathered, and later
 all such instructions are insterted into an  
\family typewriter
__entry
\family default
 function that is the entry point of every program - CPU of the VM calls
 
\family typewriter
__entry
\family default
 function when told to start running.
 Programmer-written main function is then called by the 
\family typewriter
__entry
\family default
 function after every out-of-function instruction is executed in order in
 which they were gathered.
\end_layout

\begin_layout Standard
The only constraints placed on the main functions are:
\begin_inset CommandInset label
LatexCommand label
name "Main-function-constraints"

\end_inset


\end_layout

\begin_layout Itemize
main function must be defined,
\end_layout

\begin_layout Itemize
main function must return a value,
\end_layout

\begin_layout Standard
If these conditions are not met assembler rejects the code.
\end_layout

\begin_layout Standard
Name of the main function is irrelevant as long as it is set with 
\begin_inset Quotes eld
\end_inset


\family typewriter
.main:
\family default

\begin_inset Quotes eld
\end_inset

 assembler directive and points to a defined function (constraint #1) which
 returns a value (constraint #2).
 Name of the main function defaults to 
\begin_inset Quotes eld
\end_inset


\family typewriter
main
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Assembler directives
\end_layout

\begin_layout Standard
When programming in Viua VM assembly language, one not only uses instructions
 from the CPU instruction set but also directives of the assembler.
 These include things like markers, register names and functions.
\end_layout

\begin_layout Subsection
Defining functions
\end_layout

\begin_layout Standard
Functions are composed from CPU instructions wrapped in 
\family typewriter
.function:
\family default
 and 
\family typewriter
.end
\family default
 directives.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.function: <function>
\end_layout

\begin_layout Plain Layout

    <instruction>+
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every function should end with with the 
\family typewriter
end
\family default
 instruction.
 This is not a hard requirement, and can probably be used in a similar fashion
 to 
\family typewriter
case
\family default
 inside 
\family typewriter
switch
\family default
 that do not end with 
\family typewriter
break
\family default
; because if the finishing 
\family typewriter
end
\family default
 is omitted control will just flow into the function that is defined next
 (as it would to the next 
\family typewriter
case
\family default
 inside a 
\family typewriter
switch
\family default
).
 This 
\begin_inset Quotes eld
\end_inset

fallthrough
\begin_inset Quotes erd
\end_inset

 behaviour is possible because Viua's bytecode is dense, i.e.
 there is no special separation space between functions.
\end_layout

\begin_layout Subparagraph
Warning
\end_layout

\begin_layout Standard
Despite being useful at times, the fallthrough behaviour can also be a source
 of problems.
 Consider following code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.function: one
\end_layout

\begin_layout Plain Layout

    istore 1 42
\end_layout

\begin_layout Plain Layout

    print 1
\end_layout

\begin_layout Plain Layout

    izero 0
\end_layout

\begin_layout Plain Layout

    ; no end here
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.function: main
\end_layout

\begin_layout Plain Layout

    frame 0 2
\end_layout

\begin_layout Plain Layout

    call one
\end_layout

\begin_layout Plain Layout

    izero 0
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, falling from 
\begin_inset Quotes eld
\end_inset


\family typewriter
one
\family default

\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset


\family typewriter
main
\family default

\begin_inset Quotes erd
\end_inset

 creates an infinite loop.
 As of version 0.5.0 machine is not able to defend itself from such code (it
 only offers a limited form of instruction-level protection from infinite
 loops - one that protects it from stopping on single instruction forever
 and is intended to protect from jumps to themselves).
\end_layout

\begin_layout Subsubsection
Function signatures
\begin_inset CommandInset label
LatexCommand label
name "sub:Function-signatures"

\end_inset


\end_layout

\begin_layout Standard
Assembler does not compile code that contains calls to, or instantiates
 (as closure or a function object) undefined functions.
 This is problematic when dynamic linking of Viua code is used.
 Dynamically linked Viua modules export functions which can be called with
 ordinary 
\family typewriter
CALL
\family default
 instructions or instantiated with 
\family typewriter
CLOSURE
\family default
 or 
\family typewriter
FUNCTION
\family default
 instructions and assembler ensures that these instructions reference functions
 defined in current compilation unit or in units statically linked to it.
\end_layout

\begin_layout Standard
Dynamically linked functions, by definition, are not present in currently
 compiled unit or in any units statically linked to it, so assembler sees
 them as undefined and aborts compilation.
 This compile-time check is necessary to prevent exception throwing and
 crashes at runtime.
 To allow functions from a dynamically linked unit to be used with code
 currently being compiled 
\begin_inset Quotes eld
\end_inset


\family typewriter
.signature:
\family default

\begin_inset Quotes erd
\end_inset

 directive is used.
 After assembler sees such code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.signature: dynamically_linked::function
\end_layout

\end_inset


\end_layout

\begin_layout Standard
it will trust the programmer that 
\family typewriter
dynamically_linked::function
\family default
 will be available at runtime before it will be called.
 If the function will be called before it is available an exception will
 be thrown instead of program being crashed to allow graceful recovery and,
 in case it is not caught, stack trace pinpointing location of the problem.
\end_layout

\begin_layout Subparagraph*
Warning
\end_layout

\begin_layout Standard
This directive should not be abused; it is not designed to keep the assembler
 quiet when it detects problems but to provide it with information.
 If the information is provided to mislead the assembler it will generate
 code that will eventually throw an exception about a call to undefined
 function.
 Using 
\family typewriter
.signature:
\family default
 to silence warnings about undefined function is very strongly discouraged.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Defining blocks
\end_layout

\begin_layout Standard
Blocks are composed from CPU instructions wrapped in 
\family typewriter
.block:
\family default
 and 
\family typewriter
.end
\family default
 directives.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.block: <block>
\end_layout

\begin_layout Plain Layout

    <instruction>+
\end_layout

\begin_layout Plain Layout

    leave
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every block should end with with the 
\family typewriter
leave
\family default
 instruction.
 This is a hard requirement and blocks without finishing 
\family typewriter
leave
\family default
 will cause assembler to abort compilation.
\end_layout

\begin_layout Subsubsection
Block signatures
\begin_inset CommandInset label
LatexCommand label
name "sub:Block-signatures"

\end_inset


\end_layout

\begin_layout Standard
Assembler does not compile code that contains tries of undefined blocks.
 As with functions, this is problematic when dynamic linking of Viua code
 is used.
 Adopted solution is the same as for functions; by providing a 
\begin_inset Quotes eld
\end_inset

block signature
\begin_inset Quotes erd
\end_inset

 programmers can inform the assembler that block with a given name will
 be available at runtime:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.bsignature: dynamically_linked::block
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph*
Warning
\end_layout

\begin_layout Standard
This directive should not be abused; it is not designed to keep the assembler
 quiet when it detects problems but to provide it with information.
 If the information is provided to mislead the assembler it will generate
 code that will eventually crash.
 Using 
\family typewriter
.bsignature:
\family default
 to silence warnings about undefined blocks is very strongly discouraged.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Markers
\end_layout

\begin_layout Standard
Markers are designed as means to ease jumping to different places in code.
 They can be used in 
\family typewriter
jump
\family default
 and 
\family typewriter
branch
\family default
 instructions, as shown below (assembler checks for markers in places where
 an instruction index is expected).
 To set a marker 
\family typewriter
.mark:
\family default
 directive is used.
\end_layout

\begin_layout Standard
Markers are especially useful when imlementing loops.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.function: main
\end_layout

\begin_layout Plain Layout

	istore 1 42
\end_layout

\begin_layout Plain Layout

	jump :not_so_fast
\end_layout

\begin_layout Plain Layout

	istore 1 69
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.mark: no_so_fast
\end_layout

\begin_layout Plain Layout

	print 1
\end_layout

\begin_layout Plain Layout

	izero 0
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax for setting a marker is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.mark: <marker_id>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Names (named registers)
\end_layout

\begin_layout Standard
Names can be assigned to registers to make programming in Viua VM's assembly
 language easier.
 Compare this code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.function: main
\end_layout

\begin_layout Plain Layout

	arg 0 1
\end_layout

\begin_layout Plain Layout

	; some code...
\end_layout

\begin_layout Plain Layout

	move 1 0
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.function: main
\end_layout

\begin_layout Plain Layout

	arg 0 1
\end_layout

\begin_layout Plain Layout

	.name: 7 eax
\end_layout

\begin_layout Plain Layout

    .name: 0 exit_code
\end_layout

\begin_layout Plain Layout

	; some code...
\end_layout

\begin_layout Plain Layout

	move eax exit_code
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second example should be more self-explanatory than the first one.
 In the former listing it is unclear what is being returned (we can only
 guess it is 
\family typewriter
exit_code
\family default
) while in the latter on we immediately know what's going on.
\end_layout

\begin_layout Standard
The syntax for naming registers is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.name: <register_number> <name>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Alternative main function
\end_layout

\begin_layout Standard
Alternative main function may be set using .main: directive.
 Code in the following listing will not produce an error because the assembler
 knows that main function name is changed.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.function: nondefault_main_function
\end_layout

\begin_layout Plain Layout

	istore 1 42
\end_layout

\begin_layout Plain Layout

	print 1
\end_layout

\begin_layout Plain Layout

	izero 0
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.main: nondefault_main_function
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternative main function must still meet all constraints mentioned in Section
\begin_inset CommandInset ref
LatexCommand vref
reference "Main-function-constraints"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Linking
\end_layout

\begin_layout Subsection
Static linking
\end_layout

\begin_layout Standard
Static linking is done during assembling, in linking phase.
 To indicate that a library should be linked 
\family typewriter
.link:
\family default
 directive (in asm source code) is used.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.link: main.vlib
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternatively, a list of libraries to link can be supplied to assembler
 frontend on the command line.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

./bin/vm/asm -o main.out main.asm lib1.vlib lib2.vlib libN.vlib...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The very short snippet shown in the first listing can actually assemble
 without a single warning, provided function named 
\family typewriter
main
\family default
 is defined in the 
\family typewriter
main.wlib
\family default
 library.
\end_layout

\begin_layout Standard
No special steps have to be performed on the command line to assemble program
 that links external libraries, provided that correct paths are embedded
 in source code.
 However, special steps are required when assembling a library, i.e.
 
\family typewriter
--lib
\family default
 option must be passed to the assembler.
 This will ensure no error is thrown if no main function is found, and generate
 jump table (which is not present in the executable form of the bytecode).
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Dynamic linking
\begin_inset CommandInset label
LatexCommand label
name "sub:Dynamic-linking"

\end_inset


\end_layout

\begin_layout Standard
Dynamic linking is performed during runtime.
 The fact that the assembler checks if called functions are defined can
 prove problematic at first.
 To inform the assembler that a function (or a block) will be available
 at runtime, but is not available during compilation and static linking
 stages for current unit, use 
\begin_inset Quotes eld
\end_inset


\family typewriter
.signature:
\family default

\begin_inset Quotes erd
\end_inset

 (see 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Function-signatures"

\end_inset

) and 
\begin_inset Quotes eld
\end_inset


\family typewriter
.bsignature:
\family default

\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Block-signatures"

\end_inset

) assembler directives for functions and blocks respectively.
\end_layout

\begin_layout Standard
The actual linking operation is performed during program execution.
 When the machine encounters 
\begin_inset Quotes eld
\end_inset


\family typewriter
LINK
\family default

\begin_inset Quotes erd
\end_inset

 (described 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:link"

\end_inset

) opcode it loads the library associated with it and makes functions it
 defines available to the program.
 Calls to undefined functions (which may happen if a library has not been
 linked before a call is issued to one of its functions) result in an exception
 being thrown.
 The exception is catchable from user code.
\end_layout

\begin_layout Subparagraph
Implementation detail
\end_layout

\begin_layout Standard
Currently, machine does not check if the module has been already linked.
 The side-effect of this is possiblity of reloading a module during program
 execution (similar to Erlang's upgrade).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Standard Library
\begin_inset CommandInset label
LatexCommand label
name "sec:Standard-Library"

\end_inset


\end_layout

\begin_layout Section
C++ modules
\end_layout

\begin_layout Subsection
Typesystem
\end_layout

\begin_layout Subsection
String
\end_layout

\begin_layout Section
Viua modules
\end_layout

\begin_layout Subsection
Functional
\end_layout

\begin_layout Subsection
Misc
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Debugging
\end_layout

\begin_layout Standard
Sources of Viua VM include basic debugger that allows programmers to run
 compiled programs in a controlled environment and inspect their state mid-fligh
t.
 This section explains debugger commands.
\end_layout

\begin_layout Standard
Debugger has its .rc script which can contain arbitrary commands and is placed
 in 
\begin_inset Quotes eld
\end_inset

~/.viuavm.db.rc
\begin_inset Quotes erd
\end_inset

 for local commands, and 
\begin_inset Quotes eld
\end_inset

/etc/viuavm/dbrc
\begin_inset Quotes erd
\end_inset

 for system-wide commands.
\end_layout

\begin_layout Standard
Debugging can also be aided by 
\family typewriter
--Wall
\family default
 and 
\family typewriter
--Eall
\family default
 compiler flags, which issue either a warning or error upon encountered
 mistakes.
 Be informed that some behaviours which are valid can still issue a warning
 or an error, e.g.
 functions not ending with 
\begin_inset Quotes eld
\end_inset


\family typewriter
end
\family default

\begin_inset Quotes erd
\end_inset

 instruction (it may be either a mistake, or a decision - for example when
 a programmer decides they want execution to 
\begin_inset Quotes eld
\end_inset

fall
\begin_inset Quotes erd
\end_inset

 to the next function).
 Another useful assembler flags are 
\family typewriter
--verbose,
\family default
 
\family typewriter
--debug
\family default
 and 
\family typewriter
--scream
\family default
, each causing certain messages to be displayed while compiling the code.
\end_layout

\begin_layout Section
Debugger commands
\end_layout

\begin_layout Subsection
CPU commands
\end_layout

\begin_layout Subsubsection
cpu.init
\end_layout

\begin_layout Standard
This command initializes the CPU (initialization includes setting up instruction
 pointer, and creating first frame on the call stack).
 It must be run before any other command.
\end_layout

\begin_layout Subsubsection
cpu.preload
\end_layout

\begin_layout Standard
This command executes 
\begin_inset Quotes eld
\end_inset


\family typewriter
.preload()
\family default

\begin_inset Quotes erd
\end_inset

 on the CPU and preloads libraries specified by 
\begin_inset Quotes eld
\end_inset


\family typewriter
VIUAPRELINK
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
VIUAPREIMPORT
\family default

\begin_inset Quotes erd
\end_inset

 environment variables.
\end_layout

\begin_layout Subsubsection
cpu.run
\end_layout

\begin_layout Standard
This command launches loaded program.
 The CPU will run instructions until a breakpoint or a watchpoint is encountered
, or the end of execution is reached.
\end_layout

\begin_layout Subsubsection
cpu.tick
\end_layout

\begin_layout Standard
This command accepts zero or one integer operand, which defaults to 1.
 It instructs the CPU to perform N cycles.
 If a breakpoint or a watchpoint is encountered execution is paused; if
 end of execution is reached CPU halts.
\end_layout

\begin_layout Subsubsection
cpu.resume
\end_layout

\begin_layout Standard
This command is used to resume execution after a encountering a breakpoint
 or a watchpoint.
 It will continue execution for as many ticks as were specified by previous
 
\family typewriter
cpu.run
\family default
 or 
\family typewriter
cpu.tick
\family default
 commands.
\end_layout

\begin_layout Subsubsection
cpu.unpause
\end_layout

\begin_layout Standard
This command is used to clear 
\begin_inset Quotes eld
\end_inset

paused
\begin_inset Quotes erd
\end_inset

 state of the CPU, thus allowing further execution.
 It does not immediately resume execution.
\end_layout

\begin_layout Subsubsection
cpu.jump
\end_layout

\begin_layout Standard
This instruction allows jumping to arbitrary bytes inside bytecode.
\end_layout

\begin_layout Subsubsection
cpu.unfinish
\end_layout

\begin_layout Standard
This command clears 
\begin_inset Quotes eld
\end_inset

finished
\begin_inset Quotes erd
\end_inset

 state of the CPU and allows to continue running after end of execution
 is reached (i.e.
 replaying parts of a program after jumping to them with 
\family typewriter
cpu.jump
\family default
 command).
\end_layout

\begin_layout Subsubsection
cpu.counter
\end_layout

\begin_layout Standard
This command shows how many instructions have been executed so far.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Breakpoints
\end_layout

\begin_layout Subsubsection
breakpoint.set.at
\end_layout

\begin_layout Standard
This command sets breakpoint at specified byte address or addresses.
 It accepts zero or more integer operands, each specifying an instruction
 index at which execution is to be paused.
\end_layout

\begin_layout Subsubsection
breakpoint.set.on.opcode
\end_layout

\begin_layout Standard
This command sets breakpoint on specified opcodes.
 It accepts zero or more string operands, each being a valid opcode name
 and specifying opcode upon which execution is to be paused.
\end_layout

\begin_layout Subsubsection
breakpoint.set.on.function
\end_layout

\begin_layout Standard
This command sets breakpoint on calls to function.
 It accepts zero or more string operands, each being a valid function name.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Watchpoints
\end_layout

\begin_layout Standard
Watchpoints pause execution based on a specific condition.
 They require certain checks to be performed (some quite demanding) and
 as such add much more overhead than simple breakpoints.
\end_layout

\begin_layout Standard
Execution is always paused before the instruction that would modify a register
 is executed.
\end_layout

\begin_layout Subsubsection
watch.register.(local,global,static).read
\end_layout

\begin_layout Standard
Watch local, global or static register for reads.
\end_layout

\begin_layout Subsubsection
watch.register.(local,global,static).read
\end_layout

\begin_layout Standard
Watch local, global or static register for writes.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Register inspection commands
\end_layout

\begin_layout Subsubsection
register.show
\end_layout

\begin_layout Standard
This command is used to show information about the register set being currently
 used by CPU, typically it is the 
\begin_inset Quotes eld
\end_inset

local
\begin_inset Quotes erd
\end_inset

 register set.
 The command accepts zero or more integer operands, each specifying register
 index to be printed.
 The indexes are checked to not exceed register set size.
 For empty registers, appropriate message is issued.
\end_layout

\begin_layout Subsubsection
register.local.show
\end_layout

\begin_layout Standard
This command is used to show information about local registers.
 It accepts the same operands as 
\family typewriter
register.show
\family default
 command.
\end_layout

\begin_layout Subsubsection
register.global.show
\end_layout

\begin_layout Standard
This command is used to show information about global registers.
 It accepts the same operands as 
\family typewriter
register.show
\family default
 command.
\end_layout

\begin_layout Subsubsection
register.static.show
\end_layout

\begin_layout Standard
This command is used to show information about static registers.
 It accepts the same operands as 
\family typewriter
register.show
\family default
 command.
 If no static register have been allocated for current function, this command
 will issue appropriate error message.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Call stack inspection commands
\end_layout

\begin_layout Subsubsection
arguments.show
\end_layout

\begin_layout Standard
Show arguments of the current frame.
\end_layout

\begin_layout Subsubsection
trace, stack.trace, stack.trace.show
\end_layout

\begin_layout Standard
Print simple representation of the stack trace.
 Indentation is used to show nesting level.
 This command prints name of the function, its arity, and parameters.
\end_layout

\begin_layout Subsubsection
stack.frame.show
\end_layout

\begin_layout Standard
Show more detailed information about top-most call stack frame.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Loader commands
\end_layout

\begin_layout Subsubsection
loader.function.map[.show]
\end_layout

\begin_layout Standard
Display map of function addresses.
\end_layout

\begin_layout Subsubsection
loader.block.map[.show]
\end_layout

\begin_layout Standard
Display map of block addresses.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Various commands
\end_layout

\begin_layout Subsubsection
print.ahead
\end_layout

\begin_layout Standard
Show instruction that will be executed next.
\end_layout

\begin_layout Subsubsection
quit
\end_layout

\begin_layout Standard
Quit the debugger.
\end_layout

\begin_layout Subsubsection
conf.set
\end_layout

\begin_layout Standard
Set a configuration variable for a session.
 The syntax is as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

conf.set <key> (true|false)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Available keys are: 
\family typewriter
cpu.debug
\family default
.
\end_layout

\begin_layout Subsubsection
help
\end_layout

\begin_layout Standard
List all debugger commands available.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Interfacing with C/C++ modules
\end_layout

\begin_layout Standard
This part describes mechanism implemented in Viua VM to support interfacing
 with libraries written in C/C++, and how external modules must be written.
\end_layout

\begin_layout Section
Module interface
\end_layout

\begin_layout Standard
Linked modules can be libraries written specifically for Viua VM to speed
 up programs running on it, or wrappers for existing libraries.
 In both cases, module must provide and introduction function - 
\family typewriter
exports
\family default
 which returns a 
\family typewriter
NULL
\family default
-terminated array of name/function pointer pairs.
 If any of this function cannot be found in the 
\family typewriter
.so
\family default
 file of the module it is considered invalid.
\end_layout

\begin_layout Subsection
The 
\family typewriter
exports
\family default
 function
\end_layout

\begin_layout Standard
This function must return a NULL-terminated array of name/function pointer
 pairs.
 It defines modules' interface, i.e.
 names of the functions that Viua VM will see.
 Good practice is that the actual functions be named the same as their exported
 names but this is not required.
 Definition of the 
\family typewriter
struct
\family default
 that describes single element of this array is show below:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef Type* (ExternalFunction)(Frame*, RegisterSet*, RegisterSet*);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct ExternalFunctionSpec {
\end_layout

\begin_layout Plain Layout

    const char* name;
\end_layout

\begin_layout Plain Layout

    ExternalFunction* fpointer;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Header file that contains this definition can be included with 
\begin_inset Quotes eld
\end_inset


\family typewriter
#include <viua/include/module.h>
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Compilation of external modules
\end_layout

\begin_layout Standard
Simple helper script 
\begin_inset Quotes eld
\end_inset


\family typewriter
compile_extension.sh
\family default

\begin_inset Quotes erd
\end_inset

 for compilation of external modules is shipped as a part of standard distributi
on and is located in 
\begin_inset Quotes eld
\end_inset


\family typewriter
./scripts/
\family default

\begin_inset Quotes erd
\end_inset

 directory.
 For more compex libraires it acts only as a template.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Using external modules
\end_layout

\begin_layout Standard
Example code showing interfacing with C++ can be found in source code repository
, in 
\begin_inset Quotes eld
\end_inset


\family typewriter
./sample/asm/external
\family default

\begin_inset Quotes erd
\end_inset

 directory.
\end_layout

\begin_layout Subsection
Importing modules or functions
\end_layout

\begin_layout Standard
The instruction that is used to link external modules is named 
\family typewriter
import
\family default
.
 It accepts a single string containing name of the module to be imported
 as its only operand.
 Viua will search for modules in a set of predefined paths, which is defined
 in 
\family typewriter
<viua/include/module.h>
\family default
 header file.
\end_layout

\begin_layout Subsection
Calling functions
\end_layout

\begin_layout Standard
Calling external functions is done in the same manner as native Viua VM
 functions with small change: instruction used to call the function is 
\family typewriter
excall
\family default
 instead of 
\family typewriter
call
\family default
 used for native functions.
\end_layout

\end_body
\end_document
