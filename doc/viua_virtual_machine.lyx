#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Viua Virtual Machine 0.4.6
\end_layout

\begin_layout Author
Marek Marecki
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Overview
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
This section features a brief overview of the Viua VM; its history, development
 goals, influences and various other bits and pieces of information more
 or less related to the development of the idea and resulting code of the
 virtual machine.
 It is contains more prose and casual writing than technicalities.
 More technical discussion begins in Part 
\begin_inset CommandInset ref
LatexCommand ref
reference "part:Architecture"

\end_inset

.
 VM architecture is discussed in Part
\begin_inset CommandInset ref
LatexCommand vref
reference "part:Virtual-Machine"

\end_inset

.
 People who want to dive straight into code can start at Part
\begin_inset CommandInset ref
LatexCommand vref
reference "part:Programming"

\end_inset

.
\end_layout

\begin_layout Subsection
License
\end_layout

\begin_layout Standard
Machine's code is released under GNU GPL version 3 license.
\end_layout

\begin_layout Subsection
Compilation and dependencies
\end_layout

\begin_layout Standard
To compile Viua VM one needs a C++11 capable compiler.
 Development is done on Linux machine with GCC 5.1.0.
 From version 0.4.6 machine should also be compilable by clang++ 3.6.1 and above.
 C++11 standard library is the only dependency of the VM.
 To compile the code, following command should be used:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

make -j <number of cores>
\end_layout

\begin_layout Plain Layout

make test
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First command is used to compile assembler, CPU, debugger and disassemler.
 Second command is optional and can be used to verify if VM works correctly.
\end_layout

\begin_layout Standard
Shortcut compilation scripts exist in 
\family typewriter
./scripts
\family default
 directory; 
\family typewriter
./scripts/compile
\family default
 will compile changed pieces with maximal number of threads the machine
 it is run on supports, and 
\family typewriter
./scripts/recompile
\family default
 will recompile whole project.
\end_layout

\begin_layout Subsection
History
\end_layout

\begin_layout Standard
Viua VM is a project that has been started during the Christmas break of
 2014, when I was still a student of Gdansk University of Technology.
 It was meant to be my research project, and to help me understand how languages
 can be implemented and what really happends when I 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 the programs I wrote.
\end_layout

\begin_layout Standard
As to why it has been started at all - I had taken interest in computer
 language design and implementation; lexers, parsers, virtual machines -
 the whole stack.
 The natural way for me was to take a book about the topic, start reading
 it, halfway through begin to implement things described and by the end
 of the book have a working prototype of a software.
 The book that gave me the confidence required to tackle the task of implementin
g a VM was 
\begin_inset Quotes eld
\end_inset

Language Implementation Patterns
\begin_inset Quotes erd
\end_inset

 by Terence Parr.
\end_layout

\begin_layout Standard
Apart from the above, I thought it would be just 
\begin_inset Quotes eld
\end_inset

cool
\begin_inset Quotes erd
\end_inset

 to have my own programming language.
\end_layout

\begin_layout Standard
As of February 2015, Viua VM could be programmed in simple assembly-lookalike
 language and cannot do much compared to mainstream languages.
 Add, subtract, multiply and divide two integers or floats, print a string
 to the screen, call a function (recursively or not).
 It supports separate compilation to some extent (by supporting static linking).
\end_layout

\begin_layout Standard
In April 2015, API for external modules written in C++ has been defined
 which allowed the machine to communicate with the outside world.
\end_layout

\begin_layout Standard
In May 2015, Viua gained the ability to throw and catch objects (among them
 exceptions).
 This confirmed that errors will be handled in the VM via exception catching
 mechanism.
\end_layout

\begin_layout Standard
In June 2015 machine implemented first-class functions and closures which
 enabled it to support some form of functional programming.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Virtual Machine
\begin_inset CommandInset label
LatexCommand label
name "part:Virtual-Machine"

\end_inset


\end_layout

\begin_layout Section
Instruction set
\begin_inset CommandInset label
LatexCommand label
name "sec:Instruction-set"

\end_inset


\end_layout

\begin_layout Standard
This section contains description of the VM's CPU instruction set.
 Each instruction is explained and its syntax is shown so readers can treat
 this section also as a reference for VM's assembly language.
 Opcodes are divided into several groups described under different sections.
 Integer instructions are described
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Integers"

\end_inset

, floating point instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Floats"

\end_inset

, instructions for conversion between builtin types
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Casts"

\end_inset

, Boolean instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Booleans"

\end_inset

, string (text) instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Strings"

\end_inset

, vector (data type) instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Vectors"

\end_inset

, control flow
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Control-flow"

\end_inset

, function calling
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Function-calls"

\end_inset

, closures and functional instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Closures-and-functional"

\end_inset

, operations on registers
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Operations-on-registers"

\end_inset

, exception handling
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Exceptions"

\end_inset

, interfacing with C++ code
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Interfacing-with-C++"

\end_inset

 and other instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Other-instructions"

\end_inset

.
\end_layout

\begin_layout Subsection
Integers
\begin_inset CommandInset label
LatexCommand label
name "sub:Integers"

\end_inset


\end_layout

\begin_layout Standard
These instructions are used to perform common operations on integers (like
 addition, multiplication, or comparison).
\end_layout

\begin_layout Subsubsection
izero
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
izero <register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store integer 0 in given register.
\end_layout

\begin_layout Subsubsection
istore
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
istore <register> <integer operand>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store integer in given register.
\end_layout

\begin_layout Subsubsection
iadd
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
iadd <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Add integer found in second operand to integer found in the first one, and
 store integer result in destination register.
\end_layout

\begin_layout Subsubsection
isub
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
isub <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Subtract integer found in second operand from integer found in the first
 one, and store integer result in destination register.
\end_layout

\begin_layout Subsubsection
imul
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
imul <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Multiply integer found in first operand by integer found in the second one,
 and store integer result in destination register.
\end_layout

\begin_layout Subsubsection
idiv
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
idiv <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Divide integer found in first operand by integer found in the second one,
 and store integer result in destination register.
\end_layout

\begin_layout Subsubsection
iinc
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
iinc <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Increment integer found in target register.
\end_layout

\begin_layout Subsubsection
idec
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
idec <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Decrement integer found in target register.
\end_layout

\begin_layout Subsubsection
ilt
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
ilt <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if integer found in first operand is lesser than integer found in
 the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
ilte
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
ilte <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if integer found in first operand is lesser than or equal to integer
 found in the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
igt
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
igt <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if integer found in first operand is greater than integer found in
 the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
igte
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
igte <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if integer found in first operand is greater than or equal to integer
 found in the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
ieq
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
ieq <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if integer found in first operand is equal to integer found in the
 second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsection
Floats
\begin_inset CommandInset label
LatexCommand label
name "sub:Floats"

\end_inset


\end_layout

\begin_layout Standard
These instructions are similat to their integer counterparts.
 Float subset lacks increment and decrement instructions, though.
\end_layout

\begin_layout Subsubsection
fstore
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fstore <target register> <float operand>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store a floating point number object in given target register.
\end_layout

\begin_layout Subsubsection
fadd
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fadd <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Add float found in second operand to float found in the first one, and store
 float result in destination register.
\end_layout

\begin_layout Subsubsection
fsub
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fsub <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Subtract float found in second operand from float found in the first one,
 and store float result in destination register.
\end_layout

\begin_layout Subsubsection
fmul
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fmul <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Multiply float found in first operand by float found in the second one,
 and store float result in destination register.
\end_layout

\begin_layout Subsubsection
fdiv
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fdiv <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Divide float found in first operand by float found in the second one, and
 store float result in destination register.
\end_layout

\begin_layout Subsubsection
flt
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
flt <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if float found in first operand is lesser than float found in the
 second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
flte
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
flte <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if float found in first operand is lesser than or equal to float found
 in the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
fgt
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fgt <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if float found in first operand is greater than float found in the
 second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
fgte
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
fgte <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if float found in first operand is greater than or equal to float
 found in the second one, and store boolean result in destination register.
\end_layout

\begin_layout Subsubsection
feq
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
feq <destination register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Check if float found in first operand is equal to float found in the second
 one, and store boolean result in destination register.
\end_layout

\begin_layout Subsection
Casts
\begin_inset CommandInset label
LatexCommand label
name "sub:Casts"

\end_inset


\end_layout

\begin_layout Standard
These instructions are used to provide type conversion inside VM.
\end_layout

\begin_layout Subsubsection
itof
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
itof <destination register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Convert integer found in second operand to float, and store result in destinatio
n register.
\end_layout

\begin_layout Subsubsection
ftoi
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
ftoi <destination register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Convert float found in second operand to integer, and store result in destinatio
n register.
\end_layout

\begin_layout Subsubsection
stoi
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
stoi <destination register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Convert string found in second operand to integer, and store result in destinati
on register.
\end_layout

\begin_layout Subsubsection
stof
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
stof <destination register> <source register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Convert string found in second operand to float, and store result in destination
 register.
\end_layout

\begin_layout Subsection
Booleans
\begin_inset CommandInset label
LatexCommand label
name "sub:Booleans"

\end_inset


\end_layout

\begin_layout Standard
Common boolean operations.
\end_layout

\begin_layout Subsubsection
not
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
not <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Invert boolean value of object found in target register.
 Object is converted to Boolean type if needed.
 If a unchanged form of the object is required to remain available, 
\family typewriter
not
\family default
 should be used on a copy of the object.
\end_layout

\begin_layout Subsubsection
and
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
and <target register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store result of logical conjunction of Boolean values of operand objects
 in target register.
\end_layout

\begin_layout Subsubsection
or
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
or <target register> <1st operand register> <2nd operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store result of logical disjunction of Boolean values of operand objects
 in target register.
\end_layout

\begin_layout Subsection
Strings
\begin_inset CommandInset label
LatexCommand label
name "sub:Strings"

\end_inset


\end_layout

\begin_layout Standard
Instructions implementing string support in Viua VM.
\end_layout

\begin_layout Subsubsection
strstore
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
strstore <target register> <string>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store string object in target register.
\end_layout

\begin_layout Subparagraph
Implementation detail
\end_layout

\begin_layout Standard
Strings are stored as null-terminated character sequences in bytecode.
\end_layout

\begin_layout Subsection
Vectors
\begin_inset CommandInset label
LatexCommand label
name "sub:Vectors"

\end_inset


\end_layout

\begin_layout Standard
Instructions used to perform operations on basic Viua sequences - vectors.
\end_layout

\begin_layout Subsubsection
vec
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vec <target register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store empty vector in target register.
\end_layout

\begin_layout Subsubsection
vinsert
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vinsert <target register> <object operand register> <position operand>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Insert a copy of object from object operand register into vector, at specified
 position, found in target register.
 Default position is 0.
 At-register reference can be used to load position value from a register.
\end_layout

\begin_layout Subsubsection
vpush
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vpush <target register> <object operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Push a copy of object from object operand register to vector found in target
 register.
\end_layout

\begin_layout Subsubsection
vpop
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vpop <target register> <vector operand register> <position operand>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Pop an object at specified position from vector register and store it in
 target register.
 Default position is -1.
 At-register reference can be used to load position value from a register.
\end_layout

\begin_layout Subsubsection
vat
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vat <target register> <vector operand register> <position operand>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Create a reference in target register, to an object at specified position
 inside vector register.
 Default position is -1.
 At-register reference can be used to load position value from a register.
\end_layout

\begin_layout Subsubsection
vlen
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard

\family typewriter
vlen <target register> <vector operand register>
\end_layout

\begin_layout Paragraph
Semantics
\end_layout

\begin_layout Standard
Store length of given vector target register inside target register.
 Result is an integer.
\end_layout

\begin_layout Subsection
Control flow
\begin_inset CommandInset label
LatexCommand label
name "sub:Control-flow"

\end_inset


\end_layout

\begin_layout Standard
Basic control flow capabilities.
\end_layout

\begin_layout Subsubsection
jump
\end_layout

\begin_layout Paragraph
Size
\end_layout

\begin_layout Standard
5 bytes
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1) jump 42
\end_layout

\begin_layout Plain Layout

(2) jump foo
\end_layout

\begin_layout Plain Layout

(3) jump .42
\end_layout

\begin_layout Plain Layout

(4) jump .foo
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
relative jump to instruction
\end_layout

\begin_layout Enumerate
relative jump to marker
\end_layout

\begin_layout Enumerate
absolute jump to instruction
\end_layout

\begin_layout Enumerate
absolute jump to function (functions act as global 
\begin_inset Quotes eld
\end_inset

markers
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Paragraph
Behaviour
\end_layout

\begin_layout Standard
This instruction is an unconditional jump to a specified byte inside currently
 loaded program.
\end_layout

\begin_layout Paragraph
Description
\end_layout

\begin_layout Standard
When writing ASM code, jumps can be resolved as absolute or relative (relative
 to current function's first instruction) instruction index.
 This index is then translated by bytecode generator into byte address.
\end_layout

\begin_layout Subsubsection
branch
\end_layout

\begin_layout Subsection
Function calls
\begin_inset CommandInset label
LatexCommand label
name "sub:Function-calls"

\end_inset


\end_layout

\begin_layout Standard
Function instructions.
\end_layout

\begin_layout Subsubsection
frame
\end_layout

\begin_layout Subsubsection
param
\end_layout

\begin_layout Subsubsection
paref
\end_layout

\begin_layout Subsubsection
call
\end_layout

\begin_layout Subsubsection
arg
\end_layout

\begin_layout Subsubsection
end
\end_layout

\begin_layout Subsection
Closures and functional
\begin_inset CommandInset label
LatexCommand label
name "sub:Closures-and-functional"

\end_inset


\end_layout

\begin_layout Standard
Closure instructions.
 Closures are first-class objects inside Viua VM.
 Their semantics differ slightly from those of ordinary functions.
\end_layout

\begin_layout Subsubsection
clbind
\end_layout

\begin_layout Subsubsection
closure
\end_layout

\begin_layout Subsubsection
function
\end_layout

\begin_layout Subsubsection
fcall
\end_layout

\begin_layout Subsection
Operations on registers
\begin_inset CommandInset label
LatexCommand label
name "sub:Operations-on-registers"

\end_inset


\end_layout

\begin_layout Standard
Instructions used to perform type-agnostic operations on registers.
 These include: copying, moving, swapping etc.
\end_layout

\begin_layout Subsubsection
move
\end_layout

\begin_layout Subsubsection
copy
\end_layout

\begin_layout Subsubsection
ref
\end_layout

\begin_layout Subsubsection
swap
\end_layout

\begin_layout Subsubsection
free
\end_layout

\begin_layout Subsubsection
empty
\end_layout

\begin_layout Subsubsection
isnull
\end_layout

\begin_layout Subsubsection
ress
\end_layout

\begin_layout Subsubsection
tmpri
\end_layout

\begin_layout Subsubsection
tmpro
\end_layout

\begin_layout Subsection
Exceptions
\begin_inset CommandInset label
LatexCommand label
name "sub:Exceptions"

\end_inset


\end_layout

\begin_layout Subsubsection
tryframe
\end_layout

\begin_layout Standard
Creates a frame for trying a block.
 Takes no operands.
\end_layout

\begin_layout Subsubsection
catch
\end_layout

\begin_layout Standard
Registers catcher block for a type.
 Takes two operands: a type to catch and a block name to handle it.
 Type must be given as a double-quoted string.
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

catch "Integer" handle_integer
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
try
\end_layout

\begin_layout Standard
Tries to execute a block.
 Takes one operand: block name.
\end_layout

\begin_layout Subsubsection
throw
\end_layout

\begin_layout Standard
Throws an object.
 Takes one operand: register index specifying which object should be thrown.
\end_layout

\begin_layout Subsubsection
pull
\end_layout

\begin_layout Standard
Pulls caught object into a register.
 Takes one operand: register index into which the object shall be pulled.
\end_layout

\begin_layout Subsection
Interfacing with C++ modules
\begin_inset CommandInset label
LatexCommand label
name "sub:Interfacing-with-C++"

\end_inset


\end_layout

\begin_layout Subsubsection
eximport
\end_layout

\begin_layout Subsubsection
excall
\end_layout

\begin_layout Subsection
Other instructions
\begin_inset CommandInset label
LatexCommand label
name "sub:Other-instructions"

\end_inset


\end_layout

\begin_layout Standard
Various instructions that do not fit into any other category.
\end_layout

\begin_layout Subsubsection
echo
\end_layout

\begin_layout Subsubsection
print
\end_layout

\begin_layout Subsubsection
nop
\end_layout

\begin_layout Subsubsection
halt
\end_layout

\begin_layout Section
Standard Library
\begin_inset CommandInset label
LatexCommand label
name "sec:Standard-Library"

\end_inset


\end_layout

\begin_layout Standard
This section describes standard library that Viua VM provides.
\end_layout

\begin_layout Part
Architecture
\begin_inset CommandInset label
LatexCommand label
name "part:Architecture"

\end_inset


\end_layout

\begin_layout Standard
This part describes archtecture of the VM.
\end_layout

\begin_layout Section
Register sets
\begin_inset CommandInset label
LatexCommand label
name "sec:Register-sets"

\end_inset


\end_layout

\begin_layout Standard
Viua is a register-based virtual machine.
 It comes with several register sets, and each serves different purpose.
\end_layout

\begin_layout Subsection
Global
\end_layout

\begin_layout Standard
Global register set can be used to hold global variables.
 It can be accessed from all functions.
 Initial values in this register set's registers are set by 
\family typewriter
__entry
\family default
 function.
\end_layout

\begin_layout Subsection
Local
\end_layout

\begin_layout Standard
Local regster sets are uniqe to functions and cannot be accessed from outside
 of them.
 They are created each time a function is called, live inside a call frame
 and are destoyed when the frame is popped from the call stack.
\end_layout

\begin_layout Subsection
Static
\end_layout

\begin_layout Standard
Static registers are unique to functions and cannot be accessed from outside
 of them.
 The difference between local registers is that they are created only the
 first time a function is called and are independent of call frames.
\end_layout

\begin_layout Subsection
Temporary
\end_layout

\begin_layout Standard
Temporary register set has only one register.
 It is used to move values between different register sets.
 In the future release, the number of registers in the temporary register
 set may be increased to allow performing simple operations inside it.
\end_layout

\begin_layout Section
Type system
\begin_inset CommandInset label
LatexCommand label
name "sec:Type-system"

\end_inset


\end_layout

\begin_layout Standard
This section talks about type system of Viua VM.
\end_layout

\begin_layout Section
Instruction operands
\end_layout

\begin_layout Standard
Instructions operate on registers and usually operands are just register
 indexes, this is the simplest case.
\end_layout

\begin_layout Subsection
Values
\end_layout

\begin_layout Standard
Registers that contain a value are overwritten when another value is put
 in them.
\end_layout

\begin_layout Subsection
References
\end_layout

\begin_layout Standard
Registers that contain a reference are not overwritten; instead, they adjust
 the value of the object they reference.
 The change appears in every register that holds a reference to changed
 object.
\end_layout

\begin_layout Subsection
At-register operator
\end_layout

\begin_layout Standard
If an operand is an integer it can be preceded by @ character in source
 code to create an at-register operand.
 This @ (called 
\begin_inset Quotes eld
\end_inset

at-register operator
\begin_inset Quotes erd
\end_inset

) will cause the flag before integer operand to be set to true which is
 interpreted by machine's CPU as 
\begin_inset Quotes eld
\end_inset

do not treat this literally, but rather as a register index to take actual
 value from
\begin_inset Quotes erd
\end_inset

.
 When the operand is already a register index and is preceded by at-register
 operator, machine will use value found in this register as the index used
 for final operation.
\end_layout

\begin_layout Subsubsection
Example - instruction taking register index as an operand
\end_layout

\begin_layout Standard
If an instruction takes register index (an integer) as its operand and this
 integer is preced by at-register operator, machine will use value found
 in register with index equal to given integer as the final index: 
\begin_inset Quotes eld
\end_inset

izero 1
\begin_inset Quotes erd
\end_inset

 will store 0 in first regitser, but 
\begin_inset Quotes eld
\end_inset

izero @1
\begin_inset Quotes erd
\end_inset

 will store 0 in register with index equal to the integer stored in first
 register.
\end_layout

\begin_layout Subsubsection
Example - instruction taking integer as an operand
\end_layout

\begin_layout Standard
If an instruction takes plain integer as its operand and this integer is
 preceded by at-register operator, machine will use value found in register
 with index equal to given integer as this operand: 
\begin_inset Quotes eld
\end_inset

istore 1 42
\begin_inset Quotes erd
\end_inset

 will store 42 in first register, but 
\begin_inset Quotes eld
\end_inset

istore 1 @42
\begin_inset Quotes erd
\end_inset

 will store in first register whatever integer was stored in register 42.
\end_layout

\begin_layout Section
Callables
\begin_inset CommandInset label
LatexCommand label
name "sec:Callables"

\end_inset


\end_layout

\begin_layout Standard
Callble objects in Viua VM.
\end_layout

\begin_layout Subsection
Functions
\begin_inset CommandInset label
LatexCommand label
name "sub:Functions"

\end_inset


\end_layout

\begin_layout Standard
Function objects are currently not implemented.
\end_layout

\begin_layout Subsection
Closures
\begin_inset CommandInset label
LatexCommand label
name "sub:Closures"

\end_inset


\end_layout

\begin_layout Standard
Viua has direct support for closures and, when programming in machine's
 assembly, precise control over object binding can be achieved.
 Closures are first-class objects inside Viua's type system.
 However, there are a few limitations.
\end_layout

\begin_layout Subsubsection
Creating closures
\end_layout

\begin_layout Standard
A closure can be created from any defined function written in machine's
 assembly.
 Creating closures from external functions (imported from C++ modules) is
 not supported.
\end_layout

\begin_layout Standard
Before a closure is created, machine scans current register set for registers
 marked with BIND flag.
 Any such mared register is then inserted into the local registerset of
 a closure - where it has REFERENCE flag set - and flag in current registerset
 is changed from BIND to BOUND.
 It is allowed to create closures that bind no objects - such empty closures
 can be used as a function objects.
\end_layout

\begin_layout Subsubsection
Object sharing
\end_layout

\begin_layout Standard
If an object is bound to more than one closure, pointer to this object stays
 the same in all binding closures.
 It must be noted that binding object to multiple closures leads to memory
 leaks.
 Due to the naive way machine tracks objects lifetimes it will not be able
 to determine when it can destroy a bound object because all pointers to
 it are either REFERENCEs or in BOUND registers.
\end_layout

\begin_layout Subsection
Coroutines
\begin_inset CommandInset label
LatexCommand label
name "sub:Coroutines"

\end_inset


\end_layout

\begin_layout Standard
Coroutines are a planned but currently not implemented feature.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Bytecode
\end_layout

\begin_layout Standard
This section talks about the bytecode used by Viua VM.
\end_layout

\begin_layout Section
Executable
\end_layout

\begin_layout Standard
This subsection discusses bytecode format used for executable files.
 Each subsection discusses a coresponding section of the bytecode format,
 all sections appear in text in the exact same order as they appear in bytecode.
\end_layout

\begin_layout Subsection
Function mapping
\end_layout

\begin_layout Standard
Function mapping begins with 
\family typewriter
uint16_t
\family default
 encoding size of the section.
 Following N bytes contain paired function names (encoded as null-terminated
 strings, thus variable length) and locations of their entry points (encoded
 as 
\family typewriter
uint16_t
\family default
 integers).
\end_layout

\begin_layout Standard
Format can be written as such:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<section size:uint16_t>
\end_layout

\begin_layout Plain Layout

(<name:null-terminated-string><entry_point:uint16_t>)+
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is a 
\family typewriter
+
\family default
 rather than 
\family typewriter
*
\family default
 after name/entry-point pair because there are always at least two functions
 mapped: 
\family typewriter
__entry
\family default
 and 
\family typewriter
main
\family default
.
\end_layout

\begin_layout Subsection
Block mapping
\end_layout

\begin_layout Standard
Block mapping begins with 
\family typewriter
uint16_t
\family default
 encoding size of the section.
 A block is a piece of code that is executed when throw-catch mechanism
 is in use, i.e.
 VM 
\begin_inset Quotes eld
\end_inset

tries
\begin_inset Quotes erd
\end_inset

 to execute a block, and if an exception is thrown, it executes the block
 that should 
\begin_inset Quotes eld
\end_inset

catch
\begin_inset Quotes erd
\end_inset

 it the exception.
\end_layout

\begin_layout Standard
The format is exactly the same as for function mapping.
\end_layout

\begin_layout Subsection
Executable bytecode size
\end_layout

\begin_layout Standard
Last name/entry-point pair from function mapping section is followed size
 of the executable bytecode encoded as 
\family typewriter
uint16_t
\family default
.
\end_layout

\begin_layout Subsection
Executable bytes
\end_layout

\begin_layout Standard
Size is followed by N bytes containing encoded opcodes with program logic.
\end_layout

\begin_layout Section
Linkable
\end_layout

\begin_layout Standard
This section discusses bytecode format used for libraries.
 In Viua VM there is no difference between a static and dynamic libraries.
 In fact, a library can be linked statically or dynamically without any
 changes.
 The only difference is between linkable and executable bytecode formats.
\end_layout

\begin_layout Subsection
Jump table
\end_layout

\begin_layout Standard
Linkable bytecode format begins with encoded jump table.
 This is because jumps must be recalculated before linking and providing
 jump table is faster than manually scanning bytecode for 
\family typewriter
JUMP
\family default
 and 
\family typewriter
BRANCH
\family default
 instructions.
\end_layout

\begin_layout Standard
This section begins with an 
\family typewriter
unsigned
\family default
 encoding total number of entries in the jump table.
 It is followed by N 
\family typewriter
unsigned
\family default
 integers encoding positions of jumps in linked bytecode.
 During linking they must be adjusted by increasing their targets by total
 size of bytecode that precedes them.
 The schema may look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<jumptable size:unsigned>
\end_layout

\begin_layout Plain Layout

<jump position in bytecode:unsigned>*
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Function mapping
\end_layout

\begin_layout Standard
Function mapping has the same structure as in executable bytecode format.
\end_layout

\begin_layout Subsection
Block mapping
\end_layout

\begin_layout Standard
Block mapping has the same structure as in executable bytecode format.
\end_layout

\begin_layout Subsection
Executable bytecode size
\end_layout

\begin_layout Standard
Last name/entry-point pair from function mapping section is followed size
 of the executable bytecode encoded as 
\family typewriter
uint16_t
\family default
.
\end_layout

\begin_layout Subsection
Executable bytes
\end_layout

\begin_layout Standard
Size is followed by N bytes containing encoded opcodes with library logic.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Programming
\begin_inset CommandInset label
LatexCommand label
name "part:Programming"

\end_inset


\end_layout

\begin_layout Standard
This part describes how to write programs and run them on Viua VM.
 The language used in this part is custom assembly language created for
 the VM (it is also a target to which higher-level languages can be compiled).
\end_layout

\begin_layout Section
Structure
\end_layout

\begin_layout Standard
Every Viua VM program is a composed from a set of functions.
 In fact, each assembled file must contain at least one function.
\end_layout

\begin_layout Standard
If any instruction is found outside of a function it is gathered, and later
 all such instructions are insterted into an  
\family typewriter
__entry
\family default
 function that is the entry point of every program - CPU of the VM calls
 
\family typewriter
__entry
\family default
 function when told to start running.
 Programmer-written main function is then called by the 
\family typewriter
__entry
\family default
 function after every out-of-function instruction is executed in order in
 which they were gathered.
\end_layout

\begin_layout Standard
The only constraints placed on the main functions are:
\begin_inset CommandInset label
LatexCommand label
name "Main-function-constraints"

\end_inset


\end_layout

\begin_layout Itemize
main function must be defined,
\end_layout

\begin_layout Itemize
main function must return a value,
\end_layout

\begin_layout Standard
If these conditions are not met assembler rejects the code.
\end_layout

\begin_layout Standard
Name of the main function is irrelevant as long as it is set with 
\begin_inset Quotes eld
\end_inset


\family typewriter
.main:
\family default

\begin_inset Quotes eld
\end_inset

 assembler directive and points to a defined function (constraint #1) which
 returns a value (constraint #2).
 Name of the main function defaults to 
\begin_inset Quotes eld
\end_inset


\family typewriter
main
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Assembler directives
\end_layout

\begin_layout Standard
When programming in Viua VM assembly language, one not only uses instructions
 from the CPU instruction set but also directives of the assembler.
 These include things like markers, register names and functions.
\end_layout

\begin_layout Subsection
Defining functions
\end_layout

\begin_layout Standard
Functions are composed from CPU instructions wrapped in 
\family typewriter
.def
\family default
 and 
\family typewriter
.end
\family default
 directives.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.function: <function>
\end_layout

\begin_layout Plain Layout

    <instruction>+
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every function should end with with the 
\family typewriter
end
\family default
 instruction.
 This is not a hard requirement, and can probably be used in a similar fashion
 to 
\family typewriter
case
\family default
 inside 
\family typewriter
switch
\family default
 that do not end with 
\family typewriter
break
\family default
; because if the finishing end is omitted control will just flow into the
 function that is defined next (as it would to the next 
\family typewriter
case
\family default
 inside a 
\family typewriter
switch
\family default
).
\end_layout

\begin_layout Subsection
Markers
\end_layout

\begin_layout Standard
Markers are designed as means to ease jumping to different places in code.
 They can be used in 
\family typewriter
jump
\family default
 and 
\family typewriter
branch
\family default
 instructions, as shown below (assembler checks for markers in places where
 an instruction index is expected).
 To set a marker 
\family typewriter
.mark:
\family default
 directive is used.
\end_layout

\begin_layout Standard
Markers are especially useful when imlementing loops.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.function: main
\end_layout

\begin_layout Plain Layout

	istore 1 42
\end_layout

\begin_layout Plain Layout

	jump :not_so_fast
\end_layout

\begin_layout Plain Layout

	istore 1 69
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.mark: no_so_fast
\end_layout

\begin_layout Plain Layout

	print 1
\end_layout

\begin_layout Plain Layout

	izero 0
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax for setting a marker is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.mark: <marker_id>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Names (named registers)
\end_layout

\begin_layout Standard
Names can be assigned to registers to make programming in Viua VM's assembly
 language easier.
 Compare this code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.function: main
\end_layout

\begin_layout Plain Layout

	arg 0 1
\end_layout

\begin_layout Plain Layout

	; some code...
\end_layout

\begin_layout Plain Layout

	move 1 0
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.function: main
\end_layout

\begin_layout Plain Layout

	arg 0 1
\end_layout

\begin_layout Plain Layout

	.name: 7 eax
\end_layout

\begin_layout Plain Layout

    .name: 0 exit_code
\end_layout

\begin_layout Plain Layout

	; some code...
\end_layout

\begin_layout Plain Layout

	move eax exit_code
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second example should be more self-explanatory than the first one.
 In the former listing it is unclear what is being returned (we can only
 guess it is 
\family typewriter
exit_code
\family default
) while in the latter on we immediately know what's going on.
\end_layout

\begin_layout Standard
The syntax for naming registers is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.name: <register_number> <name>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Alternative main function
\end_layout

\begin_layout Standard
Alternative main function may be set using .main: directive.
 Code in the following listing will not produce an error because the assembler
 knows that main function name is changed.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.function: nondefault_main_function
\end_layout

\begin_layout Plain Layout

	istore 1 42
\end_layout

\begin_layout Plain Layout

	print 1
\end_layout

\begin_layout Plain Layout

	izero 0
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

.end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.main: nondefault_main_function
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternative main function must still meet all constraints mentioned in Section
\begin_inset CommandInset ref
LatexCommand vref
reference "Main-function-constraints"

\end_inset

.
\end_layout

\begin_layout Section
Linking
\end_layout

\begin_layout Subsection
Static linking
\end_layout

\begin_layout Standard
Static linking is done during assembling, in linking phase.
 To indicate that a library should be linked 
\family typewriter
.link:
\family default
 directive (in asm source code) is used.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.link: main.wlib
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternatively, a list of libraries to link can be supplied to assembler
 frontend on the command line.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

./bin/vm/asm -o main.out main.asm lib1.wlib lib2.wlib libN.wlib...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The very short snippet shown in the first listing can actually assemble
 without a single warning, provided function named 
\family typewriter
main
\family default
 is defined in the 
\family typewriter
main.wlib
\family default
 library.
\end_layout

\begin_layout Standard
No special steps have to be performed on the command line to assemble program
 that links external libraries, provided that correct paths are embedded
 in source code.
 However, special steps are required when assembling a library, i.e.
 
\family typewriter
--lib
\family default
 option must be passed to the assembler.
 This will ensure no error is thrown if no main function is found, and generate
 jump table (which is not present in the executable form of the bytecode).
\end_layout

\begin_layout Subsection
Dynamic linking
\end_layout

\begin_layout Standard
Dynamic linking is a feature planned for later versions of Viua VM.
\end_layout

\begin_layout Part
Debugging
\end_layout

\begin_layout Standard
Sources of Viua VM include basic debugger that allows programmers to run
 compiled programs in a controlled environment and inspect their state mid-fligh
t.
 This section explains debugger commands.
\end_layout

\begin_layout Standard
Debugger has its .rc script which can contain arbitrary commands and is placed
 in 
\begin_inset Quotes eld
\end_inset

~/.viuavm.db.rc
\begin_inset Quotes erd
\end_inset

 for local commands, and 
\begin_inset Quotes eld
\end_inset

/etc/viuavm/dbrc
\begin_inset Quotes erd
\end_inset

 for system-wide commands.
\end_layout

\begin_layout Standard
Debugging can also be aided by 
\family typewriter
--Wall
\family default
 and 
\family typewriter
--Eall
\family default
 compiler flags, which issue either a warning or error upon encountered
 mistakes.
 Be informed that some behaviours which are valid can still issue a warning
 or an error, e.g.
 functions not ending with 
\begin_inset Quotes eld
\end_inset


\family typewriter
end
\family default

\begin_inset Quotes erd
\end_inset

 instruction (it may be either a mistake, or a decision - for example when
 a programmer decides they want execution to 
\begin_inset Quotes eld
\end_inset

fall
\begin_inset Quotes erd
\end_inset

 to the next function).
 Another useful assembler flags are 
\family typewriter
--verbose,
\family default
 
\family typewriter
--debug
\family default
 and 
\family typewriter
--scream
\family default
, each causing certain messages to be displayed while compiling the code.
\end_layout

\begin_layout Section
Debugger commands
\end_layout

\begin_layout Subsection
CPU commands
\end_layout

\begin_layout Subsubsection
cpu.init
\end_layout

\begin_layout Standard
This command initializes the CPU (initialization includes setting up instruction
 pointer, and creating first frame on the call stack).
 It must be run before any other command.
\end_layout

\begin_layout Subsubsection
cpu.run
\end_layout

\begin_layout Standard
This command launches loaded program.
 The CPU will run instructions until a breakpoint or a watchpoint is encountered
, or the end of execution is reached.
\end_layout

\begin_layout Subsubsection
cpu.tick
\end_layout

\begin_layout Standard
This command accepts zero or one integer operand, which defaults to 1.
 It instructs the CPU to perform N cycles.
 If a breakpoint or a watchpoint is encountered execution is paused; if
 end of execution is reached CPU halts.
\end_layout

\begin_layout Subsubsection
cpu.resume
\end_layout

\begin_layout Standard
This command is used to resume execution after a encountering a breakpoint
 or a watchpoint.
 It will continue execution for as many ticks as were specified by previous
 
\family typewriter
cpu.run
\family default
 or 
\family typewriter
cpu.tick
\family default
 commands.
\end_layout

\begin_layout Subsubsection
cpu.unpause
\end_layout

\begin_layout Standard
This command is used to clear 
\begin_inset Quotes eld
\end_inset

paused
\begin_inset Quotes erd
\end_inset

 state of the CPU, thus allowing further execution.
 It does not immediately resume execution.
\end_layout

\begin_layout Subsubsection
cpu.jump
\end_layout

\begin_layout Standard
This instruction allows jumping to arbitrary bytes inside bytecode.
\end_layout

\begin_layout Subsubsection
cpu.unfinish
\end_layout

\begin_layout Standard
This command clears 
\begin_inset Quotes eld
\end_inset

finished
\begin_inset Quotes erd
\end_inset

 state of the CPU and allows to continue running after end of execution
 is reached (i.e.
 replaying parts of a program after jumping to them with 
\family typewriter
cpu.jump
\family default
 command).
\end_layout

\begin_layout Subsubsection
cpu.counter
\end_layout

\begin_layout Standard
This command shows how many instructions have been executed so far.
\end_layout

\begin_layout Subsection
Breakpoints
\end_layout

\begin_layout Subsubsection
breakpoint.set.at
\end_layout

\begin_layout Standard
This command sets breakpoint at specified byte address or addresses.
 It accepts zero or more integer operands, each specifying an instruction
 index at which execution is to be paused.
\end_layout

\begin_layout Subsubsection
breakpoint.set.on.opcode
\end_layout

\begin_layout Standard
This command sets breakpoint on specified opcodes.
 It accepts zero or more string operands, each being a valid opcode name
 and specifying opcode upon which execution is to be paused.
\end_layout

\begin_layout Subsubsection
breakpoint.set.on.function
\end_layout

\begin_layout Standard
This command sets breakpoint on calls to function.
 It accepts zero or more string operands, each being a valid function name.
\end_layout

\begin_layout Subsection
Watchpoints
\end_layout

\begin_layout Standard
Watchpoints pause execution based on a specific condition.
 They require certain checks to be performed (some quite demanding) and
 as such add much more overhead than simple breakpoints.
\end_layout

\begin_layout Standard
Execution is always paused before the instruction that would modify a register
 is executed.
\end_layout

\begin_layout Subsubsection
watch.register.(local,global,static).read
\end_layout

\begin_layout Standard
Watch local, global or static register for reads.
\end_layout

\begin_layout Subsubsection
watch.register.(local,global,static).read
\end_layout

\begin_layout Standard
Watch local, global or static register for writes.
\end_layout

\begin_layout Subsection
Register inspection commands
\end_layout

\begin_layout Subsubsection
register.show
\end_layout

\begin_layout Standard
This command is used to show information about the register set being currently
 used by CPU, typically it is the 
\begin_inset Quotes eld
\end_inset

local
\begin_inset Quotes erd
\end_inset

 register set.
 The command accepts zero or more integer operands, each specifying register
 index to be printed.
 The indexes are checked to not exceed register set size.
 For empty registers, appropriate message is issued.
\end_layout

\begin_layout Subsubsection
register.local.show
\end_layout

\begin_layout Standard
This command is used to show information about local registers.
 It accepts the same operands as 
\family typewriter
register.show
\family default
 command.
\end_layout

\begin_layout Subsubsection
register.global.show
\end_layout

\begin_layout Standard
This command is used to show information about global registers.
 It accepts the same operands as 
\family typewriter
register.show
\family default
 command.
\end_layout

\begin_layout Subsubsection
register.static.show
\end_layout

\begin_layout Standard
This command is used to show information about static registers.
 It accepts the same operands as 
\family typewriter
register.show
\family default
 command.
 If no static register have been allocated for current function, this command
 will issue appropriate error message.
\end_layout

\begin_layout Subsection
Call stack commands
\end_layout

\begin_layout Subsubsection
arguments.show
\end_layout

\begin_layout Standard
Show arguments of the current frame.
\end_layout

\begin_layout Subsubsection
trace, stack.trace, stack.trace.show
\end_layout

\begin_layout Standard
Print simple representation of the stack trace.
 Indentation is used to show nesting level.
 This command prints name of the function, its arity, and parameters.
\end_layout

\begin_layout Subsubsection
stack.frame.show
\end_layout

\begin_layout Standard
Show more detailed information about top-most call stack frame.
\end_layout

\begin_layout Subsection
Loader commands
\end_layout

\begin_layout Subsubsection
loader.function.map[.show]
\end_layout

\begin_layout Standard
Display map of function addresses.
\end_layout

\begin_layout Subsubsection
loader.block.map[.show]
\end_layout

\begin_layout Standard
Display map of block addresses.
\end_layout

\begin_layout Subsection
Various commands
\end_layout

\begin_layout Subsubsection
print.ahead
\end_layout

\begin_layout Standard
Show instruction that will be executed next.
\end_layout

\begin_layout Subsubsection
quit
\end_layout

\begin_layout Standard
Quit the debugger.
\end_layout

\begin_layout Subsubsection
conf.set
\end_layout

\begin_layout Standard
Set a configuration variable for a session.
 The syntax is as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

conf.set <key> (true|false)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Available keys are: 
\family typewriter
cpu.debug
\family default
.
\end_layout

\begin_layout Subsubsection
help
\end_layout

\begin_layout Standard
List all debugger commands available.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Interfacing with C/C++ modules
\end_layout

\begin_layout Standard
This part describes mechanism implemented in Viua VM to support interfacing
 with libraries written in C/C++, and how modules must be written.
\end_layout

\begin_layout Section
Module interface
\end_layout

\begin_layout Standard
Linked modules can be libraries written specifically for Viua VM to speed
 up programs running on it, or wrappers for existing libraries.
\end_layout

\begin_layout Standard
In both cases, module must provide two functions - 
\family typewriter
exports_names
\family default
 and 
\family typewriter
exports_pointers
\family default
 which return a 
\family typewriter
NULL
\family default
-terminated arrays.
\end_layout

\begin_layout Standard
If any of these two functions cannot be found in the .so of the module it
 is considered invalid.
\end_layout

\begin_layout Subsection
The 
\family typewriter
exports_names
\family default
 function
\end_layout

\begin_layout Standard
This function must return a NULL-terminated array of 
\family typewriter
const char
\family default
 pointers.
 It defines modules' interface, i.e.
 names of the functions that Viua VM will see.
 Good practice is that the actual functions be named the same as their exported
 names but this is not required.
\end_layout

\begin_layout Subsection
The 
\family typewriter
exports_pointers
\family default
 function
\end_layout

\begin_layout Standard
This function must return a NULL-terminated array of pointers to functions
 taking 
\family typewriter
(Frame*, RegisterSet*, RegisterSet*)
\family default
 as their parameters and returning 
\family typewriter
void
\family default
.
 Convenience 
\family typewriter
typedef
\family default
 is provided.
 Viua VM will use pointers returned by this function to locate exported
 functions.
 This is to avoid having to 'extern 
\begin_inset Quotes eld
\end_inset

C
\begin_inset Quotes erd
\end_inset

' every function exported from C++ modules.
\end_layout

\begin_layout Section
Using external modules
\end_layout

\begin_layout Standard
Example code showing interfacing with C++ can be found in source code repository
, in 
\begin_inset Quotes eld
\end_inset


\family typewriter
./sample/asm/external
\family default

\begin_inset Quotes erd
\end_inset

 directory.
\end_layout

\begin_layout Subsection
Importing modules or functions
\end_layout

\begin_layout Standard
The instruction that is used to link external modules is named 
\family typewriter
eximport
\family default
.
 It accepts a single string containing name of the module to be imported
 as its only operand.
 Imported functions are namespaced, i.e.
 their names are prefixed with 
\begin_inset Quotes eld
\end_inset


\family typewriter
<module name>
\family default
.
\begin_inset Quotes erd
\end_inset

 string.
 Viua will search for modules in a set of predefined paths, which is defined
 in a header file.
\end_layout

\begin_layout Subsection
Calling functions
\end_layout

\begin_layout Standard
Calling external functions is done in the same manner as native Viua VM
 functions with small change: instruction used to call the function is 
\family typewriter
excall
\family default
 instead of 
\family typewriter
call
\family default
 used for native functions.
\end_layout

\end_body
\end_document
