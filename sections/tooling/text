\section{begin}

This section discusses tools provided in the standard distribution.

\heading{ASSEMBLER}
\section{begin}

Source code must be compiled to bytecode before execution on Viua VM kernel.
Assembler does the job of converting source files into the executable bytecode files (or libraries).

\heading{COMPILE TIME VERIFICATION}
\section{begin}

Assembler includes a simple static analyser and type checker.

\heading{TYPE CHECKER}
\section{begin}

The type checker will reject programs in which it can find errors at compile time.
For example, the following code will clearly produce an error:

\reflow{off}
\indent{4}
text %1 local "Hello World!"
integer %2 local 42
add %3 local %1 local %2 local
\dedent{4}
\reflow{on}
\break

The third instruction (`add') would cause a type error at runtime as it is not possible to add 42 to "Hello
World!".
The type checker will notice this and reject the program, producing an appropriate error message.

\heading{TYPE INFERENCE}

Viua VM assembly is a language with strong, mostly static typing, and type inference.
Not all types have to be explicitly declared: assembler will infer types when they are not expressed in source
code from the way the values defined by them are used.
In other words - the assembler will enforce consistency of the assumptions about types of values expressed in
the source code.

\section{end}

\heading{STATIC ANALYSER}
\section{begin}

Static analyser will simulate how a piece of source code would be executed and check if any errors would be
thrown.
This mostly means following branches, and verifying that register accesses are correct.

\section{end}

\section{end}

\heading{LINKER}
\section{begin}

Static linking is performed by the assembler, which also has the role of the linker in Viua VM tooling.
To link a module statically add it to the list of files the assembler takes as input.
For example, the following command will compile `main.asm' module and statically link `foo.out' and
`bar.out' to it:

\reflow{off}
\indent{4}
viua-asm main.asm foo.out bar.out
\dedent{4}
\reflow{on}
\break

Viua supports both static (compile-time) linkage and dynamic (runtime) linkage.
Dynamic linkage is implemented by the kernel, discussed in a later section.

\section{end}

\section{end}

\heading{KERNEL}
\section{begin}

Kernel is a program that executes Viua VM bytecode.
To run a program compiled into Viua VM bytecode you need both the kernel and the executable bytecode.
Then, you can invoke the program like this:

\reflow{off}
\indent{4}
viua-vm program.out --some flags
\dedent{4}
\reflow{on}
\break

The kernel will the begin running the program, starting with the `main' function.

\heading{ENVIRONMENT VARIABLES}
\section{begin}

There are environment variables that may be used to enable, disable, or otherwise affect certain kernel features.
They are listed and discussed below.

\heading{VIUA_ENABLE_TRACING}
\section{begin}

\reflow{off}
\indent{4}
$ viua-asm sample/asm/text/hello_world.asm
$ viua-vm a.out
Hello World!
$ VIUA_ENABLE_TRACING=yes viua-vm a.out
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000000780, jump_base = 0x605000c150e0, address = 0x605000d15104, depth = 1 ] ress
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000000780, jump_base = 0x605000c150e0, address = 0x605000d15106, depth = 1 ] frame
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000000780, jump_base = 0x605000c150e0, address = 0x605000d15113, depth = 1 ] call main/0
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000003000, jump_base = 0x605000c150e0, address = 0x605000d150e0, depth = 2 ] text
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000003000, jump_base = 0x605000c150e0, address = 0x605000d150f5, depth = 2 ] print
Hello World!
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000003000, jump_base = 0x605000c150e0, address = 0x605000d150fc, depth = 2 ] izero
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000003000, jump_base = 0x605000c150e0, address = 0x605000d15103, depth = 2 ] return from main/0 with no deferred
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000003000, jump_base = 0x605000c150e0, address = 0x605000d15103, depth = 2 ] return from main/0 after deferred
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000000780, jump_base = 0x605000c150e0, address = 0x605000d15121, depth = 1 ] move
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000000780, jump_base = 0x605000c150e0, address = 0x605000d1512e, depth = 1 ] halt
\dedent{4}
\reflow{on}
\break

\section{end}

\section{end}

\section{end}

\heading{DISASSEMBLER}
\section{begin}
\section{end}

\section{end}
