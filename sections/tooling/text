\section{begin}

This section discusses tools provided in the standard distribution.

\heading{ASSEMBLER}
\section{begin}

Source code must be compiled to bytecode before execution on Viua VM kernel.
Assembler does the job of converting source files into the executable bytecode files (or libraries).

\heading{COMPILE TIME VERIFICATION}
\section{begin}

Assembler includes a simple static analyser and type checker.

\heading{TYPE CHECKER}
\section{begin}

The type checker will reject programs in which it can find errors at compile time.
For example, the following code will clearly produce an error:

\reflow{off}
\indent{4}
text %1 local "Hello World!"
integer %2 local 42
add %3 local %1 local %2 local
\dedent{4}
\reflow{on}
\break

The third instruction (`add') would cause a type error at runtime as it is not possible to add 42 to "Hello
World!".
The type checker will notice this and reject the program, producing an appropriate error message.

\heading{TYPE INFERENCE}

Viua VM assembly is a language with strong, mostly static typing, and type inference.
Not all types have to be explicitly declared: assembler will infer types when they are not expressed in source
code from the way the values defined by them are used.
In other words - the assembler will enforce consistency of the assumptions about types of values expressed in
the source code.

\section{end}

\heading{STATIC ANALYSER}
\section{begin}

Static analyser will simulate how a piece of source code would be executed and check if any errors would be
thrown.
This mostly means following branches, and verifying that register accesses are correct.

\section{end}

\section{end}

\heading{LINKER}
\section{begin}

Static linking is performed by the assembler, which also has the role of the linker in Viua VM tooling.
To link a module statically add it to the list of files the assembler takes as input.
For example, the following command will compile `main.asm' module and statically link `foo.out' and
`bar.out' to it:

\reflow{off}
\indent{4}
viua-asm main.asm foo.out bar.out
\dedent{4}
\reflow{on}
\break

Viua supports both static (compile-time) linkage and dynamic (runtime) linkage.
Dynamic linkage is implemented by the kernel, discussed in a later section.

\section{end}

\section{end}

\heading{KERNEL}
\section{begin}

Kernel is a program that executes Viua VM bytecode.
To run a program compiled into Viua VM bytecode you need both the kernel and the executable bytecode.
Then, you can invoke the program like this:

\reflow{off}
\indent{4}
viua-vm program.out --some flags
\dedent{4}
\reflow{on}
\break

The kernel will the begin running the program, starting with the `main' function.

\heading{ENVIRONMENT VARIABLES}
\section{begin}

There are environment variables that may be used to enable, disable, or otherwise affect certain kernel features.
They are listed and discussed below.

\heading{VIUA_ENABLE_TRACING}
\section{begin}

Setting this variable to `yes' (`VIUA_ENABLE_TRACING=yes') will make the kernel dump execution trace of the running program.
Note that the trace is verbose, and a line is dumped to stderr for *every* executed instruction.
This means that traces can quickly get long.
\break
However, due to the verbosity and per-executed-instruction granularity they can be a great aid in debugging (of both programs
running on the VM, and the VM itself).

\wrap{begin}
\indent{4}
$ viua-asm sample/asm/text/hello_world.asm
$ viua-vm a.out
Hello World!
$ VIUA_ENABLE_TRACING=yes viua-vm a.out
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000000780, jump_base = 0x605000c150e0, address = 0x605000d15104, depth = 1 ] ress
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000000780, jump_base = 0x605000c150e0, address = 0x605000d15106, depth = 1 ] frame
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000000780, jump_base = 0x605000c150e0, address = 0x605000d15113, depth = 1 ] call main/0
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000003000, jump_base = 0x605000c150e0, address = 0x605000d150e0, depth = 2 ] text
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000003000, jump_base = 0x605000c150e0, address = 0x605000d150f5, depth = 2 ] print
Hello World!
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000003000, jump_base = 0x605000c150e0, address = 0x605000d150fc, depth = 2 ] izero
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000003000, jump_base = 0x605000c150e0, address = 0x605000d15103, depth = 2 ] return from main/0 with no deferred
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000003000, jump_base = 0x605000c150e0, address = 0x605000d15103, depth = 2 ] return from main/0 after deferred
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000000780, jump_base = 0x605000c150e0, address = 0x605000d15121, depth = 1 ] move
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000000780, jump_base = 0x605000c150e0, address = 0x605000d1512e, depth = 1 ] halt
\dedent{4}
\wrap{end}
\break

\heading{TRACE LINE EXPLAINED}
\section{begin}

Trace line contains several different pieces of information.

\wrap{begin}
\indent{4}
[ scheduler = 0x80e000000000, process = 0x913000000000, stack = 0x40b000000000, frame = 0x306000000780, jump_base = 0x605000c150e0, address = 0x605000d15104, depth = 1 ] ress
\dedent{4}
\wrap{end}
\break

\heading{SCHEDULER}

The `scheduler = ...' part identifies the scheduler that the process for which this line was emitted is running on.
Depending on how many schedulers the VM is running there can be many different schedulers.

Also, a process does not need to run on the same scheduler it was spawned on.
If the VM detects that the spawning scheduler is overloaded (i.e. that it runs more than its fair share of all running processes) the
process will be migrated to a different scheduler (a one with lighter load).

\heading{PROCESS}

The `process = ...' part identifies a process for which this line was generated.

\heading{STACK}

In Viua VM, a process may contain one active stack, and several suspended stacks.
Suspended stacks may be added, for example, by \instruction{defer} instructions (then, the
active stack is suspended when a function exits and stacks added by \instruction{defer} instructions are run).

The `stack = ...' part identifies the stack that was active in the process when the trace line was emitted.

\heading{FRAME}

The `frame = ...' part identifies the top-most frame on the stack that was active when the trace line was emitted.
It is useful when you want to track a bug that occurs on the frame boundary (just after or before a call or a return).

\heading{JUMP BASE}

The `jump_base = ...' part identifies a base that is used for resolving jumps during runtime.
Jump bases are different for different modules, so you can use this to track module boundaries (from which module came the function that
is executed in the current frame).

\heading{ADDRESS}

The `address = ...' part identifies the address at which the currently executed instruction lives.

\heading{DEPTH}

The `depth = ...' part indicates the depth of the stack in the moment the trace line was emitted.

\section{end}

\section{end}

\section{end}

\section{end}

\heading{DISASSEMBLER}
\section{begin}
\section{end}

\section{end}
