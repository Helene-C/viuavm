Viua VM is a register based VM.
Programs running on it are sequences of instructions that manipulate values placed in registers.
This section explains how registers are accessed, so that you will be able to understand the
rest of this documentation.

REGISTER SETS

\indent{}

There are three main register sets:
\reflow{off}

- local
- static
- global
\reflow{on}

Values that are placed in registers from these register sets can be accessed by any instruction.

There are alse two special register sets:
\reflow{off}

- process message queue
- exception register (a.k.a. "caught slot")
\reflow{on}

Values that are placed in these registers must be moved into a register from one of the main register sets
before they can be manipulated.
Use \instruction{receive} instruction to get values out of the process message queue, and use
\instruction{draw} instruction to get values out of the exception register (after an exception is caught).

All register sets are local to their processes.
No values are shared between processes - sending a value to another process makes a copy.

LOCAL REGISTER SET

\indent{}

Local register set is bound to a call frame, or a closure, and exists for as long as the entity it is bound to
exists.
Local register set that is bound to a call frame is discarded when that frame is dropped from the stack.
Local register set that is bound to a closure is discarded when that closure is discarded.

CAPACITY

\indent{}

Capacity of each local register set may be different (it depends on the number of registers requested when
either a frame or a closure containing the local register set is created).
The capacity is limited to 2^32 registers.

\dedent{}

NOTES

\indent{}

Tail calls do not inherit local register set.
In Viua, tail calls replace instead of reusing the last call frame (meaning that the size of the last frame
can change) so the register set is created anew.

\dedent{2}

\dedent{2}

STATIC REGISTER SET

\indent{}

Static register set is bound to a function in a process.
The same function in two different processes has two different static register sets.
Static register set is discarded when the process it is bound to finishes execution.
The order in which static register sets for different functions are discarded after a process finishes
execution is random.

CAPACITY

\indent{}

Currently (2018-01-02) fixed at 16 registers.

\dedent{}

NOTES

\indent{}

Functions are responsible for setting up their static registers.
Any call to a function may be the first one, so access to static registers should be guarded by
\instruction{isnull} instruction.

\dedent{}

\dedent{}

GLOBAL REGISTER SET

\indent{}

Global register set is bound to a process.
It is accessible from all call frames of this process.
It is discarded when the process it is bound to finishes execution.

\dedent{}

\dedent{all}

FETCH MODES

\indent{}

Values can be fetched from registers in three modes: 1/ direct, 2/ pointer dereference, and
3/ register indirect.

DIRECT

\indent{}

Direct, or plain, mode is identified by a '%' sign.
A value is fetched from a register with the index specified after the '%' sign.
For example, below code will increment a value located in local register 2:

\reflow{off}
\indent{4}
integer %2 local 42
iinc %2 local
\dedent{4}
\break

\dedent{}
\reflow{on}
POINTER DEREFERENCE

\indent{}

Pointer dereference mode (identified by '*' sign) will fetch a value that is pointed to by the pointer
located in the register with the index specified after the '*' sign.
For example, below code will increment a value pointed to by the pointer in local register 2:

\reflow{off}
\indent{4}
integer %3 local 42
ptr %2 local %3 local
iinc *2 local
\dedent{4}
\break

\dedent{}
\reflow{on}

REGISTER INDIRECT

\indent{}

Register indirect mode (identified by '@' sign) will fetch a value from a register with index specified by the
integer located in register with the index specified after the '@' sign.
For example, below code will increment a value in local register 2:

\reflow{off}
\indent{4}
integer %2 local 42
integer %3 local 2
iinc @3 local
\dedent{4}
\break

\dedent{}
\dedent{}

REGISTER ADDRESSING

\indent{}

To fetch or store a value in a register it needs to be addressed.
A proper register address consists of a fetch mode, a register index, and a register set.
For example:

\reflow{off}
\indent{4}
%1 local
*1 local
@1 local

%1 static
*1 static
@1 static

%1 global
*1 global
@1 global
\dedent{4}
\reflow{on}
\break

are all valid register addresses, conforming to the general syntax:
\break
<fetch-mode> <index> <register-set-specifier>

Mixing fetch modes and register sets in single instructions is allowed.
For exampe, this code:

\reflow{off}
\indent{4}
copy %1 static *1 local
\dedent{4}
\reflow{on}
\break

Will copy a value dereferenced from a pointer located in local register 1 into static register 1.

\dedent{all}
